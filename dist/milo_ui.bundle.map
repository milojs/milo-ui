{
  "version": 3,
  "sources": [
    "/cc-src/milo-ui/lib/components/Button.js",
    "/cc-src/milo-ui/lib/components/CheckGroup.js",
    "/cc-src/milo-ui/lib/components/Combo.js",
    "/cc-src/milo-ui/lib/components/ComboList.js",
    "/cc-src/milo-ui/lib/components/Date.js",
    "/cc-src/milo-ui/lib/components/DropTarget.js",
    "/cc-src/milo-ui/lib/components/FoldTree.js",
    "/cc-src/milo-ui/lib/components/Group.js",
    "/cc-src/milo-ui/lib/components/Hyperlink.js",
    "/cc-src/milo-ui/lib/components/Image.js",
    "/cc-src/milo-ui/lib/components/Input.js",
    "/cc-src/milo-ui/lib/components/InputList.js",
    "/cc-src/milo-ui/lib/components/List.js",
    "/cc-src/milo-ui/lib/components/ListItem.js",
    "/cc-src/milo-ui/lib/components/ListItemSimple.js",
    "/cc-src/milo-ui/lib/components/RadioGroup.js",
    "/cc-src/milo-ui/lib/components/Select.js",
    "/cc-src/milo-ui/lib/components/SuperCombo.js",
    "/cc-src/milo-ui/lib/components/Text.js",
    "/cc-src/milo-ui/lib/components/Textarea.js",
    "/cc-src/milo-ui/lib/components/Time.js",
    "/cc-src/milo-ui/lib/components/Wrapper.js",
    "/cc-src/milo-ui/lib/components/bootstrap/Alert.js",
    "/cc-src/milo-ui/lib/components/bootstrap/Dialog.js",
    "/cc-src/milo-ui/lib/components/bootstrap/Dropdown.js",
    "/cc-src/milo-ui/lib/forms/Form.js",
    "/cc-src/milo-ui/lib/forms/generator.js",
    "/cc-src/milo-ui/lib/forms/item_types.js",
    "/cc-src/milo-ui/lib/forms/registry.js",
    "/cc-src/milo-ui/lib/milo_ui.js",
    "/cc-src/milo-ui/lib/use_components.js",
    "/cc-src/milo-ui/node_modules/async/lib/async.js",
    "/cc-src/milo-ui/node_modules/browserify/node_modules/browser-builtins/builtin/fs.js",
    "/cc-src/milo-ui/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"
  ],
  "names": [],
  "mappings": ";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjvCA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLButton = Component.createComponentClass('MLButton', {\n    events: undefined,\n    dom: {\n        cls: 'ml-ui-button'\n    }\n});\n\ncomponentsRegistry.add(MLButton);\n\nmodule.exports = MLButton;\n\n_.extendProto(MLButton, {\n    disable: MLButton$disable,\n    isDisabled: MLButton$isDisabled\n});\n\n\nfunction MLButton$disable(disable) {\n    this.el.disabled = disable;\n}\n\nfunction MLButton$isDisabled() {\n    return !!this.el.disabled;\n}\n\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , uniqueId = milo.util.uniqueId;\n\n\nvar CHECKED_CHANGE_MESSAGE = 'mlcheckgroupchange'\n    , ELEMENT_NAME_PROPERTY = '_mlCheckGroupElementID'\n    , ELEMENT_NAME_PREFIX = 'ml-check-group-';\n\nvar MLCheckGroup = Component.createComponentClass('MLCheckGroup', {\n    data: {\n        set: MLCheckGroup_set,\n        get: MLCheckGroup_get,\n        del: MLCheckGroup_del,\n        splice: undefined,\n        event: CHECKED_CHANGE_MESSAGE\n    },\n    model: {\n        messages: {\n            '***': { subscriber: onOptionsChange, context: 'owner' }\n        }\n    },\n    events: {\n        messages: {\n            'click': { subscriber: onGroupClick, context: 'owner' }\n        }\n    },\n    container: undefined,\n    dom: {\n        cls: 'ml-ui-check-group'\n    },\n    template: {\n        template:  '{{~ it.checkOptions :option }} \\\n                        {{##def.elID:{{= it.elementName }}-{{= option.value }}#}} \\\n                        <span class=\"{{= it._renderOptions.optionCssClass || \"' + ELEMENT_NAME_PREFIX + 'option\" }}\"> \\\n                            <input id=\"{{# def.elID }}\" type=\"checkbox\" value=\"{{= option.value }}\" name=\"{{= it.elementName }}\"> \\\n                            <label for=\"{{# def.elID }}\">{{= option.label }}</label> \\\n                        </span> \\\n                    {{~}} \\\n                    {{?it._renderOptions.selectAll}} \\\n                        {{##def.allID:{{= it.elementName }}-all#}} \\\n                        <span class=\"' + ELEMENT_NAME_PREFIX + 'all\"> \\\n                            <input id=\"{{# def.allID }}\" type=\"checkbox\" value=\"all\" name=\"all\"> \\\n                            <label for=\"{{# def.allID }}\">All</label> \\\n                        </span> \\\n                    {{?}}'\n    }\n});\n\ncomponentsRegistry.add(MLCheckGroup);\n\nmodule.exports = MLCheckGroup;\n\n\n_.extendProto(MLCheckGroup, {\n    init: MLCheckGroup$init,\n    destroy: MLCheckGroup$destroy,\n    setSelectAll: MLCheckGroup$setSelectAll\n});\n\n\n/**\n * Component instance method\n * Initialize radio group and setup\n */\nfunction MLCheckGroup$init() {\n    _.defineProperty(this, ELEMENT_NAME_PROPERTY, ELEMENT_NAME_PREFIX + uniqueId());\n    this._renderOptions = {};\n    this._checkEls = {};\n    Component.prototype.init.apply(this, arguments);\n}\n\n\nfunction MLCheckGroup$setSelectAll(selectAll) {\n    this._renderOptions.selectAll = selectAll;\n}\n\n\n/**\n * Sets group value\n * Replaces the data set operation to deal with radio buttons\n *\n * @param {Mixed} value The value to be set\n */\nfunction MLCheckGroup_set(valueObj) {\n    _.eachKey(this._checkEls, function (el, key) {\n        el.checked = !!valueObj[key];\n    });\n}\n\n\n/**\n * Gets group value\n * Retrieves the selected value of the group\n *\n * @return {String}\n */\nfunction MLCheckGroup_get() {\n    return _.mapKeys(this._checkEls, function (el) {\n        return el.checked;\n    });\n}\n\n\n/**\n * Deleted group value\n * Deletes the value of the group, setting it to empty\n */\nfunction MLCheckGroup_del() {\n    _.eachKey(this._optionEls, function (el) {\n        el.checked = false;\n    });\n    return undefined;\n}\n\n\n/**\n * Manage radio children clicks\n */\nfunction onGroupClick(eventType, event) {\n    var clickedElement = event.target;\n    var checkboxList = this.container.scope.checkboxList;\n\n    if (clickedElement.type !== 'checkbox') return;\n\n    if (clickedElement.name === 'all') {\n        _.eachKey(this._checkEls, function (el, key) {\n            el.checked = clickedElement.checked;\n        });\n    } else {\n        var isChecked = clickedElement.checked && isAllElementChecked.call(this);\n        setAllChecked.call(this, isChecked);\n    }\n\n    dispatchChangeMessage.call(this);\n}\n\nfunction setAllChecked(checked) {\n    if (this._renderOptions.selectAll)\n        this.el.querySelector('input[name=\"all\"]').checked = checked;\n}\n\nfunction isAllElementChecked(data) {\n    return _.everyKey(this._checkEls, function (el) { return el.checked; });\n}\n\n// Post the data change\nfunction dispatchChangeMessage() {\n    this.data.dispatchSourceMessage(CHECKED_CHANGE_MESSAGE);\n}\n\n\n// Set radio button children on model change\nfunction onOptionsChange(path, data) {\n    this.template.render({\n        checkOptions: this.model.get(),\n        elementName: this[ELEMENT_NAME_PROPERTY],\n        _renderOptions: this._renderOptions\n    });\n\n    this._checkEls = {};\n    var self = this;\n    _.forEach(this.el.querySelectorAll('input[type=\"checkbox\"]'), function (el) {\n        if (el.name != 'all') self._checkEls[el.value] = el;\n    });\n}\n\n\nfunction MLCheckGroup$destroy() {\n    delete this._checkEls;\n    Component.prototype.destroy.apply(this, arguments);\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar COMBO_CHANGE_MESSAGE = 'mlcombochange';\n\nvar DATALIST_TEMPLATE = '{{~ it.comboOptions :option }} \\\n                            <option value=\"{{= option.label }}\"></option> \\\n                         {{~}}';\n\nvar MLCombo = Component.createComponentClass('MLCombo', {\n    events: undefined,\n    data: {\n        get: MLCombo_get,\n        set: MLCombo_set,\n        del: MLCombo_del,\n        splice: undefined,\n        event: COMBO_CHANGE_MESSAGE\n    },\n    model: {\n        messages: {\n            '***': { subscriber: onOptionsChange, context: 'owner' }\n        }\n    },\n    dom: {\n        cls: 'ml-ui-datalist'\n    },\n    container: undefined\n});\n\ncomponentsRegistry.add(MLCombo);\n\nmodule.exports = MLCombo;\n\n\n_.extendProto(MLCombo, {\n    init: MLCombo$init\n});\n\n\nfunction MLCombo$init() {\n    Component.prototype.init.apply(this, arguments);\n    this.on('childrenbound', onChildrenBound);\n}\n\nfunction onChildrenBound() {\n    _.defineProperties(this, {\n        '_comboInput': this.container.scope.input,\n        '_comboList': this.container.scope.datalist\n    });\n\n    this._comboList.template.set(DATALIST_TEMPLATE);\n\n    this._comboInput.data.on('input',\n        { subscriber: dispatchChangeMessage, context: this });\n}\n\nfunction MLCombo_get() {\n    if (! this._comboInput) return;\n    return this._comboInput.data.get();\n}\n\nfunction MLCombo_set(value) {\n    return changeComboData.call(this, 'set', value);\n}\n\nfunction MLCombo_del() {\n    return changeComboData.call(this, 'del', value);\n}\n\nfunction changeComboData(method, value) {\n    if (! this._comboInput) return;\n    var result = this._comboInput.data[method](value);\n    dispatchChangeMessage.call(this);\n    return result;\n}\n\n\n// Post the data change\nfunction dispatchChangeMessage() {\n    this.data.dispatchSourceMessage(COMBO_CHANGE_MESSAGE);\n}\n\nfunction onOptionsChange(msg, data) {\n    this._comboList.template.render({\n        comboOptions: this.model.get()\n    });\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , check = milo.util.check\n    , Match = check.Match;\n\nvar COMBO_LIST_CHANGE_MESSAGE = 'mlcombolistchange';\n\n\nvar MLComboList = Component.createComponentClass('MLComboList', {\n    dom: {\n        cls: 'ml-ui-combo-list'\n    },\n    data: {\n        get: MLComboList_get,\n        set: MLComboList_set,\n        del: MLComboList_del,\n        event: COMBO_LIST_CHANGE_MESSAGE\n    },\n    events: undefined,\n    container: undefined,\n    model: {\n        messages: {\n            '***': { subscriber: onItemsChange, context: 'owner'}\n        }\n    },\n    template: {\n        template: '<div ml-bind=\"MLSuperCombo:combo\"></div>\\\n                   <div ml-bind=\"MLList:list\">\\\n                       <div ml-bind=\"MLListItem:item\" class=\"list-item\">\\\n                           <span ml-bind=\"[data]:label\"></span>\\\n                           <span ml-bind=\"[events]:deleteBtn\" class=\"glyphicon glyphicon-remove\"></span>\\\n                       </div>\\\n                   </div>'\n    }\n});\n\n\ncomponentsRegistry.add(MLComboList);\n\nmodule.exports = MLComboList;\n\n\n_.extendProto(MLComboList, {\n    init: MLComboList$init,\n    setOptions: MLComboList$setOptions,\n    setDataValidation: MLComboList$setDataValidation,\n    toggleAddButton: MLComboList$toggleAddButton,\n    destroy: MLComboList$destroy,\n    setAddItemPrompt: MLComboList$setAddItemPrompt,\n    clearComboInput : MLComboList$clearComboInput\n});\n\n\nfunction MLComboList$init() {\n    Component.prototype.init.apply(this, arguments);\n    this.model.set([]);\n    this.once('childrenbound', onChildrenBound);\n}\n\n\nfunction MLComboList$setDataValidation(dataValidation) {\n    check(dataValidation, Match.Optional(Function));\n    this._dataValidation = dataValidation;\n}\n\nfunction MLComboList$setOptions(arr) {\n    this._combo.setOptions(arr);\n}\n\n\nfunction MLComboList$clearComboInput () {\n    this._combo.clearComboInput();\n}\n\n/**\n * Component instance method\n * Hides add button\n * @param {Boolean} show\n */\nfunction MLComboList$toggleAddButton(show) {\n    this._combo.toggleAddButton(show);\n}\n\n\nfunction MLComboList$setAddItemPrompt(prompt) {\n   this._combo.setAddItemPrompt(prompt);\n}\n\n\nfunction MLComboList$destroy() {\n    Component.prototype.destroy.apply(this, arguments);\n    this._connector && milo.minder.destroyConnector(this._connector);\n    this._connector = null;\n}\n\n\nfunction onChildrenBound() {\n    this.template.render().binder();\n    componentSetup.call(this);\n}\n\nfunction componentSetup() {\n    _.defineProperties(this, {\n        '_combo': this.container.scope.combo,\n        '_list': this.container.scope.list\n    });\n\n    this._connector = milo.minder(this._list.model, '<<<->>>', this.model);\n    this._combo.data.on('', { subscriber: onComboChange, context: this });\n    this._combo.on('additem', { subscriber: onAddItem, context: this });\n}\n\nfunction onComboChange(msg, data) {\n    if (data.newValue && runDataValidation.call(this, msg, data))\n        this._list.model.push(data.newValue);\n    this._combo.data.del();\n    // because of supercombo listeners off you have to set _value explicitly\n    this._combo.data._value = '';\n}\n\nfunction runDataValidation(msg, data) {\n    return this._dataValidation \n        ? this._dataValidation(msg, data, this._list.model.get())\n        : true;\n}\n\nfunction onItemsChange(msg, data) {\n    this.data.dispatchSourceMessage(COMBO_LIST_CHANGE_MESSAGE);\n}\n\nfunction MLComboList_get() {\n    var value = this.model.get();\n    return typeof value == 'object' ? _.clone(value) : value;\n}\n\nfunction MLComboList_set(value) {\n    this.model.set(value);\n}\n\nfunction MLComboList_del() {\n    return this.model.set([]);\n}\n\n\nfunction onAddItem(msg, data) {\n    this.postMessage('additem', data);\n    this.events.postMessage('milo_combolistadditem', data);\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\nvar MLDate = Component.createComponentClass('MLDate', {\n    events: undefined,\n    data: {\n        get: MLDate_get,\n        set: MLDate_set,\n        del: MLDate_del,\n    },\n    dom: {\n        cls: 'ml-ui-date'\n    }\n});\n\n_.extendProto(MLDate, {\n    getMin: MLDate$getMin,\n    setMin: MLDate$setMin,\n    getMax: MLDate$getMax,\n    setMax: MLDate$setMax\n});\n\ncomponentsRegistry.add(MLDate);\n\nmodule.exports = MLDate;\n\n\nfunction MLDate$getMin() {\n    return _.date(this.el.min);\n}\n\n\nfunction MLDate$setMin(value) {\n    var date = _.toDate(value);\n\n    this.el.min = date ? toISO8601Format(date) : '';\n}\n\n\nfunction MLDate$getMax() {\n    return _.date(this.el.max);\n}\n\n\nfunction MLDate$setMax(value) {\n    var date = _.toDate(value);\n\n    this.el.max = date ? toISO8601Format(date) : '';\n}\n\n\nfunction MLDate_get() {\n    return _.toDate(this.el.value);\n}\n\n\nfunction MLDate_set(value) {\n    var date = _.toDate(value);\n\n    this.el.value = date ? toISO8601Format(date) : '';\n\n    dispatchInputMessage.call(this);\n}\n\nfunction MLDate_del() {\n    this.el.value = '';\n\n    dispatchInputMessage.call(this);\n}\n\n\nfunction dispatchInputMessage() {\n    this.data.dispatchSourceMessage('input'); // Dispatch the 'input' (usually dispatched by the underlying <input> element) event so that the data change can be listened to\n}\n\n\nfunction toISO8601Format(date) {\n    var dateArr = [\n        date.getFullYear(),\n        pad(date.getMonth() + 1),\n        pad(date.getDate())\n    ];\n\n    var dateStr = dateArr.join('-');\n\n    return dateStr;\n\n    function pad(n) { return n < 10 ? '0' + n : n; }\n}",
    "'use strict';\n\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLDropTarget = Component.createComponentClass('MLDropTarget', ['drop']);\n\n\ncomponentsRegistry.add(MLDropTarget);\n\nmodule.exports = MLDropTarget;\n",
    "'use strict';\n\nvar doT = milo.util.doT\n    , componentsRegistry = milo.registry.components\n    , Component = milo.Component\n    , uniqueId = milo.util.uniqueId;\n\nvar TREE_TEMPLATE = '<ul class=\"ml-ui-foldtree-list\">\\\n                        {{~ it.data.items :item:index }}\\\n                            {{ var hasSubTree = item.items && item.items.length; }}\\\n                            <li {{? hasSubTree }}class=\"ml-ui-foldtree--has-multiple\"{{?}}>\\\n                                <div class=\"ml-ui-foldtree-item\" data-item-id=\"{{= it.itemIDs[index] }}\">\\\n                                    {{? hasSubTree }}\\\n                                        <div class=\"ml-ui-foldtree-button\"></div>\\\n                                    {{?}}\\\n                                    {{= it.itemTemplate({ item: item }) }}\\\n                                </div>\\\n                                {{? hasSubTree }}\\\n                                    {{= it.treeTemplate(item) }}\\\n                                {{?}}\\\n                            </li>\\\n                        {{~}}\\\n                    </ul>';\n\nvar DEFAULT_COMPILED_ITEM_TEMPLATE = doT.compile('\\\n            <span class=\"ml-ui-foldtree-label\">\\\n                {{= it.item.label }}\\\n            </span>')\n    , COMPILED_TREE_TEMPLATE = doT.compile(TREE_TEMPLATE);\n\n\nvar MLFoldTree = Component.createComponentClass('MLFoldTree', {\n    container: undefined,\n    events: {\n        messages: {\n            'click dblclick': { subscriber: onItemEvent, context: 'owner' }\n        }\n    },\n    dom: {\n        cls: 'ml-ui-foldtree-main'\n    }\n});\n\ncomponentsRegistry.add(MLFoldTree);\n\nmodule.exports = MLFoldTree;\n\n_.extendProto(MLFoldTree, {\n    setItemTemplate: MLFoldTree$setItemTemplate,\n    renderTree: MLFoldTree$renderTree,\n    setActiveItem: MLFoldTree$setActiveItem,\n    toggleItem: MLFoldTree$toggleItem\n});\n\nfunction foldUnfold(el, opened) {\n    if (opened)\n        el.classList.add('ml-ui-foldtree--unfold', opened);\n    else\n        el.classList.toggle('ml-ui-foldtree--unfold');\n}\n\nfunction itemMessage(msg, el) {\n    var id = el.getAttribute('data-item-id')\n        , item = this._itemsMap[id];\n\n    this.postMessage('mlfoldtree_' + msg, {\n        item: item,\n        el: el\n    });\n}\n\nfunction onItemEvent(msg, e) {\n    var el = e.target;\n    if (el.classList.contains('ml-ui-foldtree-button'))\n        foldUnfold(el.parentNode.parentNode);\n    else if (el.classList.contains('ml-ui-foldtree-label'))\n        itemMessage.call(this, msg, el.parentNode);\n    else return;\n    e.stopPropagation();\n}\n\nfunction MLFoldTree$setItemTemplate (templateStr) {\n    this._itemTemplate = doT.compile(templateStr);\n}\n\nfunction MLFoldTree$renderTree (data) {\n    var self = this;\n    this._data = data;\n    self._itemsMap = {};\n    this.el.innerHTML = _renderTree(data);\n\n    function _renderTree (data) {\n        if (data.items)\n            var itemsIDs = _.map(data.items, function(item) {\n                var id = item.id || uniqueId();\n                if (self._itemsMap[id]) throw new Error('MLFoldTree: item has duplicate ID:' + id);\n                self._itemsMap[id] = item;\n                return id;\n            });\n\n        return COMPILED_TREE_TEMPLATE({\n            itemIDs: itemsIDs,\n            data: data,\n            itemTemplate: self._itemTemplate || DEFAULT_COMPILED_ITEM_TEMPLATE,\n            treeTemplate: _renderTree\n        });\n    }\n}\n\n\nfunction MLFoldTree$setActiveItem(id, cssClass) {\n    cssClass = cssClass || 'ml-ui-foldtree-active';\n    var items = this.el.querySelectorAll('div.ml-ui-foldtree-item');\n    _.forEach(items, function(item) {\n        item.classList.remove(cssClass);\n    });\n    if (id) {\n        var item = this.el.querySelector('div.ml-ui-foldtree-item[data-item-id=\"' + id + '\"]');\n        item.classList.add(cssClass);\n    }\n}\n\nfunction MLFoldTree$toggleItem(id, opened) {\n    var item = this.el.querySelector('div.ml-ui-foldtree-item[data-item-id=\"' + id + '\"]');\n    foldUnfold(item.parentNode, opened);\n}\n\n\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLGroup = Component.createComponentClass('MLGroup', {\n    container: undefined,\n    data: undefined,\n    events: undefined,\n    dom: {\n        cls: 'ml-ui-group'\n    }\n});\n\ncomponentsRegistry.add(MLGroup);\n\nmodule.exports = MLGroup;\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLHyperlink = Component.createComponentClass('MLHyperlink', {\n    events: undefined,\n    data: undefined,\n    dom: {\n        cls: 'ml-ui-hyperlink'\n    }\n});\n\ncomponentsRegistry.add(MLHyperlink);\n\nmodule.exports = MLHyperlink;\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar IMAGE_CHANGE_MESSAGE = 'mlimagechange';\n\nvar MLImage = Component.createComponentClass('MLImage', {\n    data: {\n        set: MLImage_set,\n        get: MLImage_get,\n        del: MLImage_del,\n        splice: undefined,\n        event: IMAGE_CHANGE_MESSAGE\n    },\n    model: {\n        messages: {\n            '.src': { subscriber: onModelChange, context: 'owner' }\n        }\n    },\n    events: undefined,\n    container: undefined,\n    dom: {\n        tagName: 'img',\n        cls: 'ml-ui-image'\n    }\n});\n\ncomponentsRegistry.add(MLImage);\n\nmodule.exports = MLImage;\n\n\n_.extendProto(MLImage, {\n    init: MLImage$init\n});\n\n\n/**\n * Component instance method\n * Initialize radio group and setup\n */\nfunction MLImage$init() {\n    Component.prototype.init.apply(this, arguments);\n}\n\n\n/**\n * Sets image value\n * Replaces the data set operation to deal with radio buttons\n *\n * @param {Mixed} value The value to be set\n */\nfunction MLImage_set(value) {\n    this.model.set(value);\n    return value;\n}\n\n\n/**\n * Gets group value\n * Retrieves the selected value of the group\n *\n * @return {String}\n */\nfunction MLImage_get() {\n    var value = this.model.get();\n    return value && typeof value == 'object' ? _.clone(value) : value;\n}\n\n\n/**\n * Deleted group value\n * Deletes the value of the group, setting it to empty\n */\nfunction MLImage_del() {\n    this.model.del();\n}\n\n\n// Post the data change\nfunction dispatchChangeMessage() {\n    this.data.dispatchSourceMessage(IMAGE_CHANGE_MESSAGE);\n}\n\n\nfunction onModelChange(path, data) {\n    this.el.src = data.newValue;\n    dispatchChangeMessage.call(this);\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLInput = Component.createComponentClass('MLInput', {\n    data: undefined,\n    events: undefined,\n    dom: {\n        cls: 'ml-ui-input'\n    }\n});\n\ncomponentsRegistry.add(MLInput);\n\nmodule.exports = MLInput;\n\n_.extendProto(MLInput, {\n    disable: MLInput$disable,\n    isDisabled: MLInput$isDisabled,\n    setMaxLength: MLInput$setMaxLength\n});\n\nfunction MLInput$disable(disable) {\n    this.el.disabled = disable;\n}\n\nfunction MLInput$isDisabled() {\n    return !!this.el.disabled;\n}\n\nfunction MLInput$setMaxLength(length) {\n    this.el.setAttribute('maxlength', length);\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\nvar INPUT_LIST_CHANGE_MESSAGE = 'mlinputlistchange';\n\nvar asyncHandler = function (value, callback) {callback(value);};\n\nvar MLInputList = Component.createComponentClass('MLInputList', {\n    dom: {\n        cls: 'ml-ui-input-list'\n    },\n    data: {\n        get: MLInputList_get,\n        set: MLInputList_set,\n        del: MLInputList_del,\n        splice: MLInputList_splice,\n        event: INPUT_LIST_CHANGE_MESSAGE\n    },\n    events: undefined,\n    container: undefined,\n    model: {\n        messages: {\n            '***': { subscriber: onItemsChange, context: 'owner' }\n        }\n    },\n    template: {\n        template: '\\\n            <div ml-bind=\"MLList:list\">\\\n                <div ml-bind=\"MLListItem:item\" class=\"list-item\">\\\n                    <span ml-bind=\"[data]:label\"></span>\\\n                    <span ml-bind=\"[events]:deleteBtn\" class=\"glyphicon glyphicon-remove\"></span>\\\n                </div>\\\n            </div>\\\n            <input type=\"text\" ml-bind=\"MLInput:input\" class=\"form-control\">\\\n            <button ml-bind=\"MLButton:button\" class=\"btn btn-default\">\\\n                Add\\\n            </button>'\n    }\n});\n\ncomponentsRegistry.add(MLInputList);\n\nmodule.exports = MLInputList;\n\n_.extendProto(MLInputList, {\n    init: MLInputList$init,\n    setAsync: MLInputList$setAsync,\n    setPlaceHolder: MLInputList$setPlaceHolder,\n    destroy: MLInputList$destroy\n});\n\nfunction MLInputList$init() {\n    Component.prototype.init.apply(this, arguments);\n    this.once('childrenbound', onChildrenBound);\n    this.model.set([]);\n}\n\nfunction onChildrenBound() {\n    render.call(this);\n}\n\nfunction MLInputList$setPlaceHolder(placeHolder) {\n    this._input.el.setAttribute('placeHolder', placeHolder);\n}\n\nfunction MLInputList$setAsync(newHandler) {\n    asyncHandler = newHandler || asyncHandler;\n}\n\nfunction MLInputList$destroy() {\n    Component.prototype.destroy.apply(this, arguments);\n    this._connector && milo.minder.destroyConnector(this._connector);\n    this._connector = null;\n}\n\nfunction render() {\n    this.template.render().binder();\n    componentSetup.call(this);\n}\n\nfunction componentSetup() {\n    _.defineProperties(this, {\n        '_input': this.container.scope.input,\n        '_button': this.container.scope.button,\n        '_list': this.container.scope.list\n    });\n    this._connector = milo.minder(this._list.model, '<<<->>>', this.model);\n    this._button.events.on('click', {subscriber: onClick, context: this });   \n}\n\nfunction onClick(msg) {\n    var value = this._input.data.get(0);\n    if (this._input.data)\n        asyncHandler(value, function (label, value) {\n            this._list.model.push({ label: label, value: value });\n        }.bind(this));\n    this._input.data.del();\n}\n\nfunction onItemsChange(msg, data) {\n    this.data.dispatchSourceMessage(INPUT_LIST_CHANGE_MESSAGE);\n}\n\nfunction MLInputList_get() {\n    var model = this.model.get();\n    return model ? _.clone(model) : undefined;\n}\n\nfunction MLInputList_set(value) {\n    this.model.set(value);\n}\n\nfunction MLInputList_del() {\n    return this.model.set([]);\n}\n\nfunction MLInputList_splice() { // ... arguments\n    this.model.splice.apply(this.model, arguments);\n}",
    "'use strict';\n\nvar MLList = module.exports = milo.createComponentClass({\n    className: 'MLList',\n    facets: {\n        dom: {\n            cls: 'ml-ui-list'\n        },\n        data: undefined,\n        events: undefined,\n        model: undefined,\n        list: undefined\n    },\n    methods: {\n        init: MLList$init,\n        destroy: MLList$destroy,\n        removeItem: MLList$removeItem,\n        moveItem: MLList$moveItem\n    }\n});\n\n\nfunction MLList$init() {\n    MLList.super.init.apply(this, arguments);\n    this.on('childrenbound', onChildrenBound);\n}\n\n\nfunction MLList$destroy() {\n    this._connector && milo.minder.destroyConnector(this._connector);\n    this._connector = null;\n    MLList.super.destroy.apply(this, arguments);\n}\n\n\nfunction MLList$removeItem(index) {\n    this.model.splice(index, 1);\n}\n\n\nfunction MLList$moveItem(from, to) {\n    var splicedData = this.model.splice(from, 1);\n    return this.model.splice(to, 0, splicedData[0]);\n}\n\n\nfunction onChildrenBound() {\n    this.model.set([]);\n    this._connector = milo.minder(this.model, '<<<-', this.data).deferChangeMode('<<<->>>');\n}\n",
    "'use strict';\n\nvar DragDrop = milo.util.dragDrop;\n\nvar MLListItem = module.exports = milo.createComponentClass({\n    className: 'MLListItem',\n    superClassName: 'MLListItemSimple',\n    facets: {\n        drag: {\n            messages: {\n                'dragstart': { subscriber: onDragStart, context: 'owner' }\n            },\n            meta: {\n                params: 'getMetaData'\n            }\n        },\n        drop: {\n            messages: {\n                'dragenter': { subscriber: onDragHover, context: 'owner' },\n                'dragover': { subscriber: onDragHover, context: 'owner' },\n                'dragleave': { subscriber: onDragOut, context: 'owner' },\n                'drop': { subscriber: onItemDrop, context: 'owner' }\n            },\n            allow: {\n                components: isComponentAllowed\n            }\n        }\n    },\n    methods: {\n        init: MLListItem$init,\n        moveItem: MLListItem$moveItem,\n        removeItem: MLListItem$removeItem,\n        getMetaData: MLListItem$getMetaData,\n        isDropAllowed: MLListItem$isDropAllowed\n    }\n});\n\n\nfunction MLListItem$init() {\n    MLListItem.super.init.apply(this, arguments);\n    this.on('childrenbound', onChildrenBound);\n}\n\n\nfunction onChildrenBound() {\n    var deleteBtn = this.container.scope.deleteBtn;\n    deleteBtn && deleteBtn.events.on('click', { subscriber: this.removeItem, context: this });\n}\n\n\nfunction MLListItem$removeItem() {\n    try { var listOwner = this.item.list.owner; } catch(e) {}\n    listOwner && listOwner.removeItem(this.item.index);\n}\n\n\nfunction MLListItem$moveItem(index) {\n    var listOwner = this.item.list.owner;\n    listOwner && listOwner.moveItem(this.item.index, index);\n}\n\n\nfunction MLListItem$isDropAllowed(meta/*, dragDrop*/){\n    var Component = milo.registry.components.get(meta.compClass);\n\n    return meta.params && _.isNumeric(meta.params.index)\n            && (Component == MLListItem || Component.prototype instanceof MLListItem)\n            && draggingFromSameList.call(this);\n}\n\n\nfunction draggingFromSameList(comp) {\n    comp = comp || DragDrop.service.getCurrentDragSource();\n    try { var sourceList = comp.item.list; } catch(e) {}\n    return sourceList == this.item.list;\n}\n\n\nfunction isComponentAllowed() {\n    return this.isDropAllowed.apply(this, arguments);\n}\n\n\nfunction onItemDrop(eventType, event) {\n    onDragOut.call(this);\n    var dt = new DragDrop(event);\n    var meta = dt.getComponentMeta();\n    var state = dt.getComponentState();\n    var listOwner = this.item.list.owner;\n    var index = meta.params && meta.params.index;\n    var dropPosition = DragDrop.getDropPositionY(event, this.el);\n    var isBelow = dropPosition == 'below';\n    var isAbove = dropPosition == 'above';\n    var targetIndex;\n\n    if (draggingFromSameList.call(this)){\n        if(state.compName == this.name) return;\n        var stateIndex = state.facetsStates.item.state.index;\n        var isMoveDown = stateIndex < this.item.index;\n        var isSamePosition;\n        if(isMoveDown) {\n            isSamePosition = isAbove && stateIndex + 1 == this.item.index;\n            if(isSamePosition) return;\n            targetIndex = this.item.index - isAbove;\n        }\n        else {//move up\n            isSamePosition = isBelow && stateIndex - 1 == this.item.index;\n            if(isSamePosition) return;\n            targetIndex = this.item.index + isBelow;\n        }\n        listOwner.moveItem(+index, targetIndex, state);\n    }\n    else {\n        targetIndex = this.item.index + isBelow;\n        try { var data = state.facetsStates.data.state; } catch(e) {}\n        listOwner.data.splice(targetIndex, 0, data);\n    }\n}\n\n\nfunction onDragStart(/*eventType, event*/) {\n    DragDrop.service.once('dragdropcompleted', { subscriber: onDragDropCompleted, context: this });\n}\n\n\nfunction onDragHover(/*eventType, event*/) {\n    this.dom.addCssClasses('ml-drag-over');\n}\n\n\nfunction onDragOut(/*eventType, event*/) {\n    this.dom.removeCssClasses('ml-drag-over');\n}\n\n\nfunction onDragDropCompleted(msg, data) {\n    var dropTarget = data.component;\n    var droppedInAnotherList = data.eventType == 'drop' && !draggingFromSameList.call(this, dropTarget);\n    if (droppedInAnotherList) this.item.removeItem();\n}\n\n\nfunction MLListItem$getMetaData() {\n    return {\n        index: this.item.index\n    };\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar LISTITEM_CHANGE_MESSAGE = 'mllistitemchange';\n\nvar MLListItemSimple = Component.createComponentClass('MLListItemSimple', {\n    container: undefined,\n    dom: undefined,\n    data: {\n        get: MLListItemSimple_get,\n        set: MLListItemSimple_set,\n        del: MLListItemSimple_del,\n        event: LISTITEM_CHANGE_MESSAGE\n    },\n    model: undefined,\n    item: undefined\n});\n\ncomponentsRegistry.add(MLListItemSimple);\n\nmodule.exports = MLListItemSimple;\n\n\nfunction MLListItemSimple_get() {\n    var value = this.model.get();\n    return value !== null && typeof value == 'object' ? _.clone(value) : value;\n}\n\n\nfunction MLListItemSimple_set(value) {\n    if (typeof value == 'object')\n        this.data._set(value);\n    this.model.set(value);\n    _sendChangeMessage.call(this);\n    return value;\n}\n\n\nfunction MLListItemSimple_del() {\n    this.data._del();\n    this.model.del();\n    _sendChangeMessage.call(this);\n}\n\n\nfunction _sendChangeMessage() {\n    this.data.dispatchSourceMessage(LISTITEM_CHANGE_MESSAGE);\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , uniqueId = milo.util.uniqueId;\n\n\nvar RADIO_CHANGE_MESSAGE = 'mlradiogroupchange'\n    , ELEMENT_NAME_PROPERTY = '_mlRadioGroupElementID'\n    , ELEMENT_NAME_PREFIX = 'ml-radio-group-';\n\nvar MLRadioGroup = Component.createComponentClass('MLRadioGroup', {\n    data: {\n        set: MLRadioGroup_set,\n        get: MLRadioGroup_get,\n        del: MLRadioGroup_del,\n        splice: undefined,\n        event: RADIO_CHANGE_MESSAGE\n    },\n    model: {\n        messages: {\n            '***': { subscriber: onOptionsChange, context: 'owner' }\n        }\n    },\n    events: {\n        messages: {\n            'click': { subscriber: onGroupClick, context: 'owner' }\n        }\n    },\n    container: undefined,\n    dom: {\n        cls: 'ml-ui-radio-group'\n    },\n    template: {\n        template: '{{~ it.radioOptions :option }} \\\n                        {{##def.elID:{{= it.elementName }}-{{= option.value }}#}} \\\n                        <span class=\"{{= it._renderOptions.optionCssClass || \"' + ELEMENT_NAME_PREFIX + 'option\" }}\"> \\\n                            <input id=\"{{# def.elID }}\" type=\"radio\" value=\"{{= option.value }}\" name=\"{{= it.elementName }}\"> \\\n                            <label for=\"{{# def.elID }}\">{{= option.label }}</label> \\\n                        </span> \\\n                   {{~}}'\n    }\n});\n\ncomponentsRegistry.add(MLRadioGroup);\n\nmodule.exports = MLRadioGroup;\n\n\n_.extendProto(MLRadioGroup, {\n    init: MLRadioGroup$init,\n    destroy: MLRadioGroup$destroy,\n    setRenderOptions: MLRadioGroup$setRenderOptions\n});\n\n\n/**\n * Component instance method\n * Initialize radio group and setup\n */\nfunction MLRadioGroup$init() {\n    _.defineProperty(this, '_radioList', [], _.CONF);\n    _.defineProperty(this, ELEMENT_NAME_PROPERTY, ELEMENT_NAME_PREFIX + uniqueId());\n    this._renderOptions = {};\n    Component.prototype.init.apply(this, arguments);\n}\n\n\nfunction MLRadioGroup$setRenderOptions(options) {\n    this._renderOptions = options;\n}\n\n\n/**\n * Sets group value\n * Replaces the data set operation to deal with radio buttons\n *\n * @param {Mixed} value The value to be set\n */\nfunction MLRadioGroup_set(value) {\n    var options = this._radioList\n        , setResult;\n    if (options.length) {\n        options.forEach(function(radio) {\n            radio.checked = radio.value == value;\n            if (radio.checked)\n                setResult = value;\n        });\n\n        dispatchChangeMessage.call(this);\n\n        return setResult;\n    }\n}\n\n\n/**\n * Gets group value\n * Retrieves the selected value of the group\n *\n * @return {String}\n */\nfunction MLRadioGroup_get() {\n    var checked = _.find(this._radioList, function(radio) {\n        return radio.checked;\n    });\n\n    return checked && checked.value || undefined;\n}\n\n\n/**\n * Deleted group value\n * Deletes the value of the group, setting it to empty\n */\nfunction MLRadioGroup_del() {\n    var options = this._radioList;\n    if (options.length)\n        options.forEach(function(radio) {\n            radio.checked = false;\n        });\n\n    dispatchChangeMessage.call(this);\n    return undefined;\n}\n\n\n/**\n * Manage radio children clicks\n */\nfunction onGroupClick(eventType, event) {\n    if (event.target.type == 'radio')\n        dispatchChangeMessage.call(this);\n}\n\n// Post the data change\nfunction dispatchChangeMessage() {\n    this.data.dispatchSourceMessage(RADIO_CHANGE_MESSAGE);\n}\n\n\n// Set radio button children on model change\nfunction onOptionsChange(path, data) {\n    this.template.render({\n        radioOptions: this.model.get(),\n        elementName: this[ELEMENT_NAME_PROPERTY],\n        _renderOptions: this._renderOptions\n    });\n\n    var radioEls = this.el.querySelectorAll('input[type=\"radio\"]')\n        , options = _.toArray(radioEls);\n\n    this._radioList.length = 0;\n    this._radioList.splice.apply(this._radioList, [0, 0].concat(options));\n}\n\n\nfunction MLRadioGroup$destroy() {\n    delete this._radioList;\n    Component.prototype.destroy.apply(this, arguments);\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\nvar SELECT_CHANGE_MESSAGE = 'mlselectchange';\n\nvar MLSelect = Component.createComponentClass('MLSelect', {\n    dom: {\n        cls: 'ml-ui-select'\n    },\n    data: {\n        set: MLSelect_set,\n        get: MLSelect_get,\n        del: MLSelect_del,\n        splice: undefined,\n        event: SELECT_CHANGE_MESSAGE\n    },\n    events: {\n        messages: {\n            'change': { subscriber: dispatchChangeMessage, context: 'owner' }\n        }\n    },\n    model: {\n        messages: {\n            '**': { subscriber: onOptionsChange, context: 'owner' }\n        }\n    },\n    template: {\n        template: '{{~ it.selectOptions :option }} \\\n                        <option value=\"{{= option.value }}\" {{? option.selected }}selected{{?}}>{{= option.label }}</option> \\\n                   {{~}}'\n    }\n});\n\n\ncomponentsRegistry.add(MLSelect);\n\nmodule.exports = MLSelect;\n\n\n_.extendProto(MLSelect, {\n    init: MLSelect$init,\n    setOptions: MLSelect$setOptions,\n    disable: MLSelect$disable\n});\n\n\nfunction MLSelect$init() {\n    Component.prototype.init.apply(this, arguments);\n    this._optionEls = {};\n    this._isMultiple = this.el.hasAttribute('multiple');\n}\n\n\nfunction MLSelect$setOptions(options) {\n    // Set options temporarily disables model subscriptions (As a workaround for performance issues relating to model updates / template re-rendering)\n    var modelChangeListener = { context: this, subscriber: onOptionsChange };\n\n    this.model.off('**', modelChangeListener);\n    this.model.set(options);\n    this.model.on('**', modelChangeListener);\n\n    onOptionsChange.call(this);\n}\n\n\nfunction MLSelect$disable(disable) {\n    this.el.disabled = disable;\n}\n\n\nfunction MLSelect_set(strOrObj) {\n    if (!this._isMultiple) this.el.value = strOrObj;\n    else {\n        var valueObj = {};\n        if (strOrObj && typeof strOrObj == 'object') valueObj = strOrObj;\n        else valueObj[strOrObj] = true;\n        _.eachKey(this._optionEls, function (el, key) {\n            el.selected = !!valueObj[key];\n        });\n    }\n    dispatchChangeMessage.call(this);\n}\n\n\nfunction MLSelect_get() {\n    if (!this._isMultiple) return this.el.value;\n    else {\n        return _.mapKeys(this._optionEls, function (el) {\n            return el.selected;\n        });\n    }\n}\n\n\nfunction MLSelect_del() {\n    if (!this._isMultiple) this.el.value = undefined;\n    else {\n        _.eachKey(this._optionEls, function (el) {\n            el.selected = false;\n        });\n    }\n    dispatchChangeMessage.call(this);\n}\n\n\nfunction dispatchChangeMessage() {\n    this.data.dispatchSourceMessage(SELECT_CHANGE_MESSAGE);\n}\n\n\nfunction onOptionsChange(path, data) {\n    this.template.render({ selectOptions: this.model.get() });\n    this._optionEls = {};\n    var self = this;\n    _.forEach(this.el.querySelectorAll('option'), function (el) {\n        self._optionEls[el.value] = el;\n    });\n    //dispatchChangeMessage.call(this);\n}\n",
    "'use strict';\n\n/**\n * MLSuperCombo\n * A combo select list with intelligent scrolling of super large lists.\n */\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , doT = milo.util.doT\n    , logger = milo.util.logger;\n\nvar COMBO_OPEN = 'ml-ui-supercombo-open';\nvar COMBO_CHANGE_MESSAGE = 'mlsupercombochange';\n\nvar OPTIONS_TEMPLATE = '{{~ it.comboOptions :option:index }}\\\n                            <div {{? option.selected}}class=\"selected\" {{?}}data-value=\"{{= index }}\">{{= option.label }}</div>\\\n                        {{~}}';\n\nvar MAX_RENDERED = 100;\nvar BUFFER = 25;\nvar DEFAULT_ELEMENT_HEIGHT = 20;\n\nvar MLSuperCombo = Component.createComponentClass('MLSuperCombo', {\n    events: {\n        messages: {\n            'mouseleave': {subscriber: onMouseLeave, context: 'owner'},\n            'mouseover': {subscriber: onMouseOver, context: 'owner'}\n        }\n    },\n    data: {\n        get: MLSuperCombo_get,\n        set: MLSuperCombo_set,\n        del: MLSuperCombo_del,\n        splice: undefined,\n        event: COMBO_CHANGE_MESSAGE\n    },\n    dom: {\n        cls: 'ml-ui-supercombo'\n    },\n    template: {\n        template: '<input ml-bind=\"[data, events]:input\" class=\"form-control ml-ui-input\">\\\n                   <div ml-bind=\"[dom]:addItemDiv\" class=\"ml-ui-supercombo-add\">\\\n                        <span ml-bind=\":addPrompt\"></span>\\\n                        <button ml-bind=\"[events, dom]:addBtn\" class=\"btn btn-default ml-ui-button\">Add</button>\\\n                   </div>\\\n                   <div ml-bind=\"[dom, events]:list\" class=\"ml-ui-supercombo-dropdown\">\\\n                       <div ml-bind=\"[dom]:before\"></div>\\\n                       <div ml-bind=\"[template, dom, events]:options\" class=\"ml-ui-supercombo-options\"></div>\\\n                       <div ml-bind=\"[dom]:after\"></div>\\\n                   </div>'\n    },\n    container: undefined\n});\n\ncomponentsRegistry.add(MLSuperCombo);\n\nmodule.exports = MLSuperCombo;\n\n/**\n * Public Api\n */\n_.extendProto(MLSuperCombo, {\n    init: MLSuperCombo$init,\n    showOptions: MLSuperCombo$showOptions,\n    hideOptions: MLSuperCombo$hideOptions,\n    toggleOptions: MLSuperCombo$toggleOptions,\n    setOptions: MLSuperCombo$setOptions,\n    initOptionsURL: MLSuperCombo$initOptionsURL,\n    setFilteredOptions: MLSuperCombo$setFilteredOptions,\n    update: MLSuperCombo$update,\n    toggleAddButton: MLSuperCombo$toggleAddButton,\n    setAddItemPrompt: MLSuperCombo$setAddItemPrompt,\n    setPlaceholder: MLSuperCombo$setPlaceholder,\n    setFilter: MLSuperCombo$setFilter,\n    clearComboInput: MLSuperCombo_del\n});\n\n\n/**\n * Component instance method\n * Initialise the component, wait for childrenbound, setup empty options arrays.\n */\nfunction MLSuperCombo$init() {\n    Component.prototype.init.apply(this, arguments);\n\n    this.once('childrenbound', onChildrenBound);\n\n    _.defineProperties(this, {\n        _optionsData: [],\n        _filteredOptionsData: [],\n        _filterFunc: defaultFilter\n    }, _.WRIT);\n}\n\n/**\n * Handler for init childrenbound listener. Renders template.\n */\nfunction onChildrenBound() {\n    this.template.render().binder();\n    componentSetup.call(this);\n}\n\n\n/**\n * Define instance properties, get subcomponents, call setup sub-tasks\n */\nfunction componentSetup() {\n    var scope = this.container.scope;\n\n    _.defineProperties(this, {\n        _comboInput: scope.input,\n        _comboList: scope.list,\n        _comboOptions: scope.options,\n        _comboBefore: scope.before,\n        _comboAfter: scope.after,\n        _comboAddItemDiv: scope.addItemDiv,\n        _comboAddPrompt: scope.addPrompt,\n        _comboAddBtn: scope.addBtn,\n        _optionTemplate: doT.compile(OPTIONS_TEMPLATE)\n    });\n\n    _.defineProperties(this, {\n        _startIndex: 0,\n        _endIndex: MAX_RENDERED,\n        _hidden: false,\n        _elementHeight: DEFAULT_ELEMENT_HEIGHT,\n        _total: 0,\n        _optionsHeight: 200,\n        _lastScrollPos: 0,\n        _currentValue: null,\n        _selected: null,\n        _isAddButtonShown: false\n    }, _.WRIT);\n\n    // Component Setup\n    this.dom.setStyles({ position: 'relative' });\n    setupComboList(this._comboList, this._comboOptions, this);\n    setupComboInput(this._comboInput, this);\n    setupComboBtn(this._comboAddBtn, this);\n\n    this.events.on('keydown', { subscriber: changeSelected, context: this });\n    //this.events.on('mouseleave', { subscriber: MLSuperCombo$hideOptions, context: this });\n}\n\n/**\n * Component instance method\n * Shows or hides option list.\n *\n * @param {Boolean} show true to show, false to hide\n */\nfunction MLSuperCombo$toggleOptions(show) {\n    this._hidden = !show;\n    this._comboList.dom.toggle(show);\n}\n\n/**\n * Component instance method\n * Shows options list\n */\nfunction MLSuperCombo$showOptions() {\n    // Position the list to maximise the amount of visible content\n    var bounds = this.el.getBoundingClientRect();\n    var pageHeight = Math.max(this.el.ownerDocument.documentElement.clientHeight, window.innerHeight || 0);\n    var listTopStyle = ''; // Positions options underneath the combobox (Default behaviour)\n    var bottomOverlap = (bounds.bottom + this._optionsHeight) - pageHeight;\n\n    if(bottomOverlap > 0) {\n        var topOverlap = this._optionsHeight - bounds.top;\n\n        if(topOverlap < bottomOverlap) {\n            listTopStyle = - this._optionsHeight + 'px'; // Position options above the combobox\n        }\n    }\n\n    this._comboList.dom.setStyles({ top: listTopStyle });\n    this._hidden = false;\n    this.el.classList.add(COMBO_OPEN);\n    this._comboList.dom.toggle(true);\n}\n\n/**\n * Component instance method\n * Hides options list\n */\nfunction MLSuperCombo$hideOptions() {\n    this._hidden = true;\n    this.el.classList.remove(COMBO_OPEN);\n    this._comboList.dom.toggle(false);\n}\n\n/**\n * Component instance method\n * Hides add button\n */\nfunction MLSuperCombo$toggleAddButton(show, options) {\n    this._comboAddItemDiv.dom.toggle(show);\n    if (options && options.preserveState) this.__showAddOnClick = this._isAddButtonShown;\n    this._isAddButtonShown = show;\n}\n\n\nfunction MLSuperCombo$setAddItemPrompt(prompt) {\n    this._addItemPrompt = prompt;\n    this._comboAddPrompt.el.innerHTML = prompt;\n    this.toggleAddButton(false);\n}\n\n\nfunction MLSuperCombo$setPlaceholder(placeholder) {\n    this._comboInput.el.placeholder = placeholder;\n}\n\n\n/**\n * Set the filter function used in the text field\n * @param {Function} func A function with the arguments `[text, option]` which will interate \n * through all `options`, testing each against the entered `text`. WARNING: Setting a function \n * could interfere with logic use to determing if an item is unique for the add item button.\n */\nfunction MLSuperCombo$setFilter(func) {\n    this._filterFunc = func;\n}\n\n\n/**\n * Component instance method\n * Sets the options of the dropdown\n *\n * @param {Array[Object]} arr the options to set with label and value pairs. Value can be an object.\n */\nfunction MLSuperCombo$setOptions(arr) {\n    this._optionsData = arr;\n    this.setFilteredOptions(arr);\n\n    setSelected.call(this, arr[0]);\n}\n\n\n/**\n * Component instance method\n * Initialise the remote options of the dropdown\n *\n * @param {Object} options the options to initialise.\n */\nfunction MLSuperCombo$initOptionsURL(options) {\n    this._optionsURL = options.url;\n    this._formatOptionsURL = options.formatOptions || function(e){return e;};\n}\n\n\n/**\n * Private method\n * Sets the options of the dropdown based on a request\n */\nfunction _getOptionsURL(cb) {\n    var url = this._optionsURL,\n        queryString = this._comboInput.data.get();\n    var self = this;\n    cb = cb || _.noop;\n    milo.util.request.post(url, { name: queryString }, function (err, response) {\n        if (err) {\n            logger.error('Can not search for \"' + queryString + '\"');\n            return cb(new Error('Request error'));\n        }\n\n        var responseData = _.jsonParse(response);\n        if (responseData) cb(null, responseData);\n        else cb(new Error('Data error'));\n    });\n}\n\n\n/**\n * Component instance method\n * Sets the filtered options, which is a subset of normal options\n *\n * @param {[type]} arr The options to set\n */\nfunction MLSuperCombo$setFilteredOptions(arr) {\n    if (! arr) return logger.error('setFilteredOptions: parameter is undefined');\n    this._filteredOptionsData = arr;\n    this._total = arr.length;\n    this.update();\n}\n\n/**\n * Component instance method\n * Updates the list. This is used on scroll, and makes use of the filteredOptions to\n * intelligently show a subset of the filtered list at a time.\n */\nfunction MLSuperCombo$update() {\n    var wasHidden = this._hidden;\n\n    var arrToShow = this._filteredOptionsData.slice(this._startIndex, this._endIndex);\n\n    this._comboOptions.template.render({\n        comboOptions: arrToShow\n    });\n\n    this._elementHeight = this._elementHeight || DEFAULT_ELEMENT_HEIGHT;\n\n    if (wasHidden)\n        this.hideOptions();\n\n    var beforeHeight = this._startIndex * this._elementHeight;\n    var afterHeight = (this._total - this._endIndex) * this._elementHeight;\n    this._comboBefore.el.style.height = beforeHeight + 'px';\n    this._comboAfter.el.style.height = afterHeight > 0 ? afterHeight + 'px' : '0px';\n}\n\n/**\n * Setup the combo list\n *\n * @param  {Component} list\n * @param  {Array} options\n * @param  {Component} self\n */\nfunction setupComboList(list, options, self) {\n    self.toggleAddButton(false);\n    options.template.set(OPTIONS_TEMPLATE);\n\n    list.dom.setStyles({\n        overflow: 'scroll',\n        height: self._optionsHeight + 'px',\n        width: '100%',\n        position: 'absolute',\n        zIndex: 10\n        // top: yPos + 'px',\n        // left: xPos + 'px',\n    });\n\n    self.hideOptions();\n    list.events.onMessages({\n        'click': {subscriber: onListClick, context: self},\n        'scroll': {subscriber: onListScroll, context: self}\n    });\n}\n\n/**\n * Setup the input component\n *\n * @param  {Component} input\n * @param  {Component} self\n */\nfunction setupComboInput(input, self) {\n    input.events.once('focus', function(){\n        input.data.on('', { subscriber: onDataChange, context: self });\n        input.events.on('click', {subscriber: onInputClick, context: self });\n        input.events.on('keydown', {subscriber: onEnterKey, context: self });\n    });\n}\n\n/**\n * Setup the button\n * @param  {Component} btn\n * @param  {Component} self\n */\nfunction setupComboBtn(btn, self) {\n    btn.events.on('click', { subscriber: onAddBtn, context: self });\n}\n\n\n/**\n * Custom data facet get method\n */\nfunction MLSuperCombo_get() {\n    return this._currentValue;\n}\n\n/**\n * Custom data facet set method\n * @param {Variable} obj\n */\nfunction MLSuperCombo_set(obj) {\n    this._currentValue = obj;\n    this._comboInput.data.set(obj && obj.label);\n    this.data.dispatchSourceMessage(COMBO_CHANGE_MESSAGE);\n\n    var self = this;\n\n    _.defer(function() {\n        self.hideOptions();\n        self.setFilteredOptions(self._optionsData);\n        self.update();\n    });\n}\n\n/**\n * Custom data facet del method\n */\nfunction MLSuperCombo_del() {\n    this._currentValue = null;\n    this._comboInput.data.set('');\n    this.data.dispatchSourceMessage(COMBO_CHANGE_MESSAGE);\n}\n\n\n/**\n * Input data change handler\n * When the input data changes, this method filters the optionsData, and sets the first element\n * to be selected.\n * @param  {String} msg\n * @param  {Objext} data\n */\nfunction onDataChange(msg, data) {\n    var text = data.newValue && data.newValue.trim();\n    if (this._optionsURL) {\n        var self = this;\n        _getOptionsURL.call(this, function(err, responseData){\n            if (err || !responseData) return;\n            try {\n                var options = responseData.data.map(self._formatOptionsURL);\n                self.setOptions(options);\n                _updateOptionsAndAddButton.call(self, text, self._optionsData);\n            } catch(e) {\n                logger.error('Data error', e);\n            }\n        });\n    } else {\n        var filteredData = _filterData.call(this, text);\n        _updateOptionsAndAddButton.call(this, text, filteredData);\n    }\n}\n\n\nfunction _filterData(text) {\n    return this._optionsData.filter(_.partial(this._filterFunc, text));\n}\n\n\nfunction defaultFilter(text, option) {\n    if (! option.label) return false;\n    var label = option.label.toLowerCase();\n    return label.trim().toLowerCase().indexOf(text.toLowerCase()) == 0;\n}\n\n\nfunction _updateOptionsAndAddButton(text, filteredArr) {\n    if (!text) {\n        this.toggleAddButton(false, { preserveState: true });\n        setSelected.call(this, filteredArr[0]);\n    } else {\n        if (filteredArr.length && _.find(filteredArr, isExactMatch)) {\n            this.toggleAddButton(false, { preserveState: true });\n        } else if (this._addItemPrompt) {\n            this.toggleAddButton(this._optionsData.length > 1 || this._optionsURL);\n        }\n\n        if (filteredArr.length) {\n            this.showOptions();\n            setSelected.call(this, filteredArr[0]);\n        } else {\n            this.hideOptions();\n        }\n    }\n\n    this.setFilteredOptions(filteredArr);\n    this._comboList.el.scrollTop = 0;\n\n    function isExactMatch(item) {\n        return item.label.toLowerCase() === text.toLowerCase();\n    }\n}\n\n/**\n * A map of keyCodes to directions\n * @type {Object}\n */\nvar directionMap = { '40': 1, '38': -1 };\n\n/**\n * List keydown handler\n * Changes the selected list item by finding the adjacent item and setting it to selected.\n *\n * @param  {string} type\n * @param  {Event} event\n */\nfunction changeSelected(type, event) {\n    //TODO test mocha\n    var direction = directionMap[event.keyCode];\n\n    if(direction)\n        _changeSelected.call(this, direction);\n}\n\nfunction _changeSelected(direction) {\n    // TODO: refactor and tidy up, looks like some code duplication.\n    var selected = this.el.querySelector('.selected');\n    var newSelection = this._filteredOptionsData[0]; // Default if no selectedEl\n    var scrollPos = this._comboList.el.scrollTop;\n    var selectedPos = selected ? selected.offsetTop : 0;\n    var relativePos = selectedPos - scrollPos;\n\n    if (selected) {\n        var index = _getDataValueFromElement.call(this, selected);\n        var thisItem = this._filteredOptionsData[index];\n        newSelection = this._filteredOptionsData[index + direction];\n    }\n\n    setSelected.call(this, newSelection);\n    this.update();\n\n    if (relativePos > this._optionsHeight - this._elementHeight * 2 && direction === 1)\n        this._comboList.el.scrollTop += this._elementHeight * direction * 5;\n\n    if (relativePos < this._elementHeight && direction === -1)\n        this._comboList.el.scrollTop += this._elementHeight * direction * 5;\n}\n\n\n/**\n * Mouse over handler\n *\n * @param  {String} type\n * @param  {Event} event\n */\nfunction onMouseOver(type, event) {\n    this._mouseIsOver = true;\n}\n\n\n/**\n * Mouse leave handler\n *\n * @param  {String} type\n * @param  {Event} event\n */\nfunction onMouseLeave(type, event) {\n    var self = this;\n    this._mouseIsOver = false;\n    if (this._mouseOutTimer) clearInterval(this._mouseOutTimer);\n    this._mouseOutTimer = setTimeout(function(){\n        if (!self._mouseIsOver)\n            _onMouseLeave.call(self);\n    }, 750);\n}\n\nfunction _onMouseLeave() {\n    this.hideOptions();\n    this.toggleAddButton(false, { preserveState: true });\n}\n\n\n/**\n * Input click handler\n *\n * @param  {String} type\n * @param  {Event} event\n */\nfunction onInputClick(type, event) {\n    this.showOptions();\n    this._comboInput.el.setSelectionRange(0, this._comboInput.el.value.length);\n    if (this.__showAddOnClick) this.toggleAddButton(true);\n}\n\n\n/**\n * Enter key handler\n *\n * @param  {String} type\n * @param  {Event} event\n */\nfunction onEnterKey(type, event) {\n    if (event.keyCode == 13) {\n        if (this._selected)\n            _setData.call(this);\n    }\n}\n\n/**\n * Add button handler\n *\n * @param  {String} type\n * @param  {Event} event\n */\nfunction onAddBtn (type, event) {\n    var data = { label: this._comboInput.el.value };\n    this.postMessage('additem', data);\n    this.events.postMessage('milo_supercomboadditem', data);\n    this.toggleAddButton(false, { preserveState: true });\n\n}\n\n/**\n * List click handler\n *\n * @param  {String} type\n * @param  {Event} event\n */\nfunction onListClick (type, event) {\n    var index = _getDataValueFromElement.call(this, event.target);\n    var data = this._filteredOptionsData[index];\n\n    setSelected.call(this, data);\n    _setData.call(this);\n    this.update();\n}\n\n\n/**\n * List scroll handler\n *\n * @param  {String} type\n * @param  {Event} event\n */\nfunction onListScroll (type, event) {\n    var scrollPos = event.target.scrollTop\n        , direction = scrollPos > this._lastScrollPos ? 'down' : 'up'\n        , firstChild = this._comboOptions.el.lastElementChild\n        , lastChild = this._comboOptions.el.firstElementChild\n        , lastElPosition = firstChild ? firstChild.offsetTop : 0\n        , firstElPosition = lastChild ? lastChild.offsetTop : 0\n        , distFromLastEl = lastElPosition - scrollPos - this._optionsHeight + this._elementHeight\n        , distFromFirstEl = scrollPos - firstElPosition\n        , elsFromStart = Math.floor(distFromFirstEl / this._elementHeight)\n        , elsToTheEnd = Math.floor(distFromLastEl / this._elementHeight)\n        , totalElementsBefore = Math.floor(scrollPos / this._elementHeight) - BUFFER;\n\n    if ((direction == 'down' && elsToTheEnd < BUFFER)\n        || (direction == 'up' && elsFromStart < BUFFER)) {\n        this._startIndex = totalElementsBefore > 0 ? totalElementsBefore : 0;\n        this._endIndex = totalElementsBefore + MAX_RENDERED;\n        this._elementHeight = firstChild.style.height;\n        this.update();\n    }\n    this._lastScrollPos = scrollPos;\n}\n\n\n/**\n * Private method\n * Retrieves the data-value attribute value from the element and returns it as an index of\n * the filteredOptions\n *\n * @param  {Element} el\n * @return {Number}\n */\nfunction _getDataValueFromElement(el) {\n    return Number(el.getAttribute('data-value')) + this._startIndex;\n}\n\n/**\n * Private method\n * Sets the data of the SuperCombo, taking care to reset some things and temporarily\n * unsubscribe data listeners.\n */\nfunction _setData() {\n    this.hideOptions();\n    this.toggleAddButton(false);\n    this._comboInput.data.off('', { subscriber: onDataChange, context: this });\n    //supercombo listeners off\n    this.data.set(this._selected);\n    this._comboInput.data.on('', { subscriber: onDataChange, context: this });\n    //supercombo listeners on\n}\n\nfunction setSelected(value) {\n    if (this._selected) delete this._selected.selected;\n\n    if (value) {\n        this._selected = value;\n        this._selected.selected = true;\n    }\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLText = Component.createComponentClass('MLText', {\n    data: undefined,\n    events: undefined,\n    dom: {\n        cls: 'ml-ui-text'\n    }\n});\n\ncomponentsRegistry.add(MLText);\n\nmodule.exports = MLText;\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , logger = milo.util.logger;\n\n\nvar MLTextarea = Component.createComponentClass('MLTextarea', {\n    data: undefined,\n    events: undefined,\n    dom: {\n        cls: 'ml-ui-textarea'\n    }\n});\n\ncomponentsRegistry.add(MLTextarea);\n\nmodule.exports = MLTextarea;\n\n\nvar SAMPLE_AUTORESIZE_TEXT = 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit,';\n\n\n_.extendProto(MLTextarea, {\n    startAutoresize: MLTextarea$startAutoresize,\n    stopAutoresize: MLTextarea$stopAutoresize,\n    isAutoresized: MLTextarea$isAutoresized,\n    disable: MLTextarea$disable\n});\n\n\nfunction MLTextarea$startAutoresize(options) {\n    if (this._autoresize)\n        return logger.warn('MLTextarea startAutoresize: autoresize is already on');\n    this._autoresize = true;\n    this._autoresizeOptions = options;\n\n    _adjustAreaHeight.call(this);\n    _manageSubscriptions.call(this, 'on');\n}\n\n\nfunction _manageSubscriptions(onOff) {\n    this.events[onOff]('click', { subscriber: _adjustAreaHeight, context: this });\n    this.data[onOff]('', { subscriber: _adjustAreaHeight, context: this });\n}\n\n\nfunction _adjustAreaHeight() {\n    this.el.style.height = 0;\n\n    var newHeight = this.el.scrollHeight\n        , minHeight = this._autoresizeOptions.minHeight\n        , maxHeight = this._autoresizeOptions.maxHeight;\n\n    newHeight = newHeight >= maxHeight\n                ? maxHeight\n                : newHeight <= minHeight\n                ? minHeight\n                : newHeight;\n\n    this.el.style.height = newHeight + 'px';\n}\n\n\nfunction MLTextarea$stopAutoresize() {\n    if (! this._autoresize)\n        return logger.warn('MLTextarea stopAutoresize: autoresize is not on');\n    this._autoresize = false;\n    _manageSubscriptions.call(this, 'off');\n}\n\n\nfunction MLTextarea$isAutoresized() {\n    return this._autoresize;\n}\n\n\nfunction MLTextarea$destroy() {\n    if (this._autoresize)\n        this.stopAutoresize();\n    Component.prototype.destroy.apply(this, arguments);\n}\n\nfunction MLTextarea$disable(disable) {\n    this.el.disabled = disable;\n}",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLTime = Component.createComponentClass('MLTime', {\n    events: undefined,\n    data: {\n        get: MLTime_get,\n        set: MLTime_set,\n        del: MLTime_del,\n    },\n    dom: {\n        cls: 'ml-ui-time'\n    }\n});\n\ncomponentsRegistry.add(MLTime);\n\nmodule.exports = MLTime;\n\n\nvar TIME_REGEX = /^([0-9]{1,2})(?:\\:|\\.)([0-9]{1,2})$/\n    , TIME_TEMPLATE = 'hh:mm';\n\nfunction MLTime_get() {\n    var timeStr = this.el.value;\n    var match = timeStr.match(TIME_REGEX);\n    if (! match) return;\n    var hours = match[1]\n        , mins = match[2];\n    if (hours > 23 || mins > 59) return;\n    var time = new Date(1970, 0, 1, hours, mins);\n\n    return _.toDate(time);\n}\n\n\nfunction MLTime_set(value) {\n    var time = _.toDate(value);\n    if (! time) {\n        this.el.value = '';\n        return;\n    }\n\n    var timeStr = TIME_TEMPLATE\n            .replace('hh', pad(time.getHours()))\n            .replace('mm', pad(time.getMinutes()));\n\n    this.el.value = timeStr;\n    return timeStr;\n\n    function pad(n) {return n < 10 ? '0' + n : n; }\n}\n\n\nfunction MLTime_del() {\n    this.el.value = '';\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components;\n\n\nvar MLWrapper = Component.createComponentClass('MLWrapper', {\n    container: undefined,\n    data: undefined,\n    events: undefined,\n    dom: {\n        cls: 'ml-ui-wrapper'\n    }\n});\n\ncomponentsRegistry.add(MLWrapper);\n\nmodule.exports = MLWrapper;\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , componentName = milo.util.componentName\n    , logger = milo.util.logger\n    , check = milo.util.check\n    , Match = check.Match;\n\n\nvar ALERT_CSS_CLASSES = {\n    success: 'alert-success',\n    warning: 'alert-warning',\n    info: 'alert-info',\n    danger: 'alert-danger',\n    fixed: 'alert-fixed'\n};\n\n\nvar MLAlert = Component.createComponentClass('MLAlert', {\n    container: undefined,\n    events: undefined,\n    dom: {\n        cls: ['ml-bs-alert', 'alert', 'fade'],\n        attributes: {\n            'role': 'alert',\n            'aria-hidden': 'true'\n        }\n    },\n    template: {\n        template: '\\\n            {{? it.close }}\\\n                <button ml-bind=\"[events]:closeBtn\" type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">&times;</button>\\\n            {{?}}\\\n            {{= it.message}}'\n    }\n});\n\ncomponentsRegistry.add(MLAlert);\n\nmodule.exports = MLAlert;\n\n\n_.extend(MLAlert, {\n    createAlert: MLAlert$$createAlert,\n    openAlert: MLAlert$$openAlert,\n});\n\n\n_.extendProto(MLAlert, {\n    openAlert: MLAlert$openAlert,\n    closeAlert: MLAlert$closeAlert\n});\n\n\n/**\n * Creates and returns a new alert instance. To create and open at the same time use [openAlert](#MLAlert$$openAlert)\n * `options` is an object with the following properties:\n *\n *      message: string alert message\n *      type:    optional string the type of alert message, one of success, warning, info, danger, fixed\n *               default 'info'\n *      close:   optional false to prevent user from closing\n *               or true (default) to enable closing and render a close button\n *      timeout: optional timer, in milliseconds to automatically close the alert\n *\n * @param {Object} options alert configuration\n */\nfunction MLAlert$$createAlert(options) {\n    check(options, {\n        message: String,\n        type: Match.Optional(String),\n        close: Match.Optional(Boolean),\n        timeout: Match.Optional(Number)\n    });\n\n    var alert = MLAlert.createOnElement();\n\n    options = _prepareOptions(options);\n\n    var alertCls = ALERT_CSS_CLASSES[options.type];\n    alert.dom.addCssClasses(alertCls);\n\n    alert._alert = {\n        options: options,\n        visible: false\n    };\n\n    alert.template.render(options).binder();\n\n    var alertScope = alert.container.scope;\n\n    if (options.close)\n        alertScope.closeBtn.events.on('click',\n            { subscriber: _onCloseBtnClick, context: alert });\n\n    if (options.timeout)\n        var timer = setTimeout(function(){\n            if(alert._alert.visible)\n                alert.closeAlert();\n        }, options.timeout);\n\n    return alert;\n}\n\n\n/**\n * Create and show alert popup\n *\n * @param {Object} options object with message, type, close and timeout\n * @return {MLAlert} the alert instance\n */\nfunction MLAlert$$openAlert(options) {\n    var alert = MLAlert.createAlert(options);\n    alert.openAlert();\n    return alert;\n}\n\n\nfunction _onCloseBtnClick(type, event) {\n    this.closeAlert();\n}\n\n\nfunction _prepareOptions(options) {\n    options = _.clone(options);\n    options.close = typeof options.close == 'undefined' || options.close === true;\n    options.timeout = Math.floor(options.timeout);\n    options.type = options.type || 'info';\n\n    return options;\n}\n\n\n/**\n * Open the alert\n */\nfunction MLAlert$openAlert() {\n    _toggleAlert.call(this, true);\n}\n\n\n/**\n * Close the alert\n */\nfunction MLAlert$closeAlert() {\n    _toggleAlert.call(this, false);\n    this.destroy();\n}\n\n\nfunction _toggleAlert(doShow) {\n    doShow = typeof doShow == 'undefined'\n                ? ! this._alert.visible\n                : !! doShow;\n\n    var addRemove = doShow ? 'add' : 'remove'\n        , appendRemove = doShow ? 'appendChild' : 'removeChild';\n\n    this._alert.visible = doShow;\n\n    document.body[appendRemove](this.el);\n    this.dom.toggle(doShow);\n    this.el.setAttribute('aria-hidden', !doShow);\n    this.el.classList[addRemove]('in');\n    this.el[doShow ? 'focus' : 'blur']();\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , componentName = milo.util.componentName\n    , logger = milo.util.logger\n    , check = milo.util.check\n    , Match = check.Match;\n\n\nvar DEFAULT_BUTTONS = [ { type: 'default', label: 'OK', result: 'OK' } ];\n\nvar CLOSE_OPTIONS = ['backdrop', 'keyboard', 'button'];\n\nvar BUTTON_CSS_CLASSES = { // TODO - use in template\n    default: 'btn-default',\n    primary: 'btn-primary',\n    success: 'btn-success',\n    info: 'btn-info',\n    warning: 'btn-warning',\n    danger: 'btn-danger',\n    link: 'btn-link'\n};\n\n\n/**\n * Dialog class to show custom dialog boxes based on configuration - see [createDialog](#MLDialog$$createDialog) method.\n * Only one dialog can be opened at a time - trying to open another will log error to console. Currently opened dialog can be retrieved using [getCurrentDialog](#MLDialog$$getCurrentDialog) class method.\n */\nvar MLDialog = Component.createComponentClass('MLDialog', {\n    container: undefined,\n    events: undefined,\n    dom: {\n        cls: ['ml-bs-dialog', 'modal', 'fade'],\n        attributes: {\n            'role': 'dialog',\n            'aria-hidden': 'true'\n        }\n    },\n    template: {\n        template: '\\\n            <div class=\"modal-dialog {{= it.cssClass }}\">\\\n                <div class=\"modal-content\">\\\n                    {{? it.title }}\\\n                        <div class=\"modal-header\">\\\n                            {{? it.close.button }}\\\n                                <button ml-bind=\"[events]:closeBtn\" type=\"button\" class=\"close\">&times;</button>\\\n                            {{?}}\\\n                            <h4 class=\"modal-title\">{{= it.title }}</h4>\\\n                        </div>\\\n                    {{?}}\\\n                    {{? it.html || it.text }}\\\n                        <div class=\"modal-body\" ml-bind=\"[container]:dialogBody\">\\\n                            {{? it.html }}\\\n                                {{= it.html }}\\\n                            {{??}}\\\n                                <p>{{= it.text }}</p>\\\n                            {{?}}\\\n                        </div>\\\n                    {{?}}\\\n                    {{? it.buttons && it.buttons.length }}\\\n                        <div class=\"modal-footer\">\\\n                            {{~ it.buttons :btn }}\\\n                                <button type=\"button\"\\\n                                    class=\"btn btn-{{= btn.type }}{{? btn.cls }} {{= btn.cls }}{{?}}\"\\\n                                    ml-bind=\"[events]:{{= btn.name }}\">{{= btn.label }}</button>\\\n                            {{~}}\\\n                        </div>\\\n                    {{?}}\\\n                </div>\\\n            </div>'\n    }\n});\n\ncomponentsRegistry.add(MLDialog);\n\nmodule.exports = MLDialog;\n\n\n_.extend(MLDialog, {\n    createDialog: MLDialog$$createDialog,\n    openDialog: MLDialog$$openDialog,\n    getOpenedDialog: MLDialog$$getOpenedDialog\n});\n\n\n_.extendProto(MLDialog, {\n    openDialog: MLDialog$openDialog,\n    closeDialog: MLDialog$closeDialog,\n    destroy: MLDialog$destroy\n});\n\n\n/**\n * Creates and returns dialog instance. To create and open at the same time [openDialog](#MLDialog$$openDialog)\n * `options` is an object with the following properties:\n *\n *     title: optional dialog title\n *     html: optional dialog text as html (will take precedence over text if both text nd html are passed)\n *       or\n *     text: optional dialog text\n *     close: optional false to prevent backdrop and esc key from closing the dialog and removing close button in top right corner\n *            or true (default) to enable all close options\n *            or object with properties\n *         backdrop: false or true (default), close dialog when backdrop clicked\n *         keyboard: false or true (default), close dialog when esc key is pressed\n *         button: false or true (default), show close button in the header (won't be shown if there is no header when title is not passed)\n *     buttons: optional array of buttons configurations, where each button config is an object\n *         name:   optional name of component, should be unique and should not be `closeBtn`, if not passed a timestamp based name will be used\n *         type:   button type, will determine button CSS style. Possible types are: defult, primary, success, info, warning, danger, link (map to related bootstrap button styles)\n *         label:  button label\n *         close:  optional false to prevent this button from closing dialog\n *         result: string with dialog close result that will be passed to dialog subscriber as the first parameter\n *         data:   any value/object or function to create data that will be passed to dialog subscriber as the second parameter.\n *                 If function is passed it will be called with dialog as context and button options as parameter.\n *\n *     If `title` is not passed, dialog will not have title section\n *     If neither `text` nor `html` is passed, dialog will not have body section.\n *     If `buttons` are not passed, there will only be OK button.\n *\n * When dialog is closed, the subscriber is called with reault and optional data as defined in buttons configurations.\n * If backdrop is clicked or ESC key is pressed the result will be 'dismissed'\n * If close button in the top right corner is clicked, the result will be 'closed' (default result)\n *\n * @param {Object} options dialog configuration\n * @param {Function} initialize function that is called to initialize the dialog\n */\nfunction MLDialog$$createDialog(options, initialize) {\n    check(options, {\n        title: Match.Optional(String),\n        html: Match.Optional(String),\n        text: Match.Optional(String),\n        close: Match.Optional(Match.OneOf(Boolean, {\n            backdrop: Match.Optional(Boolean),\n            keyboard: Match.Optional(Boolean),\n            button: Match.Optional(Boolean)\n        })),\n        buttons: Match.Optional([ {\n            name: Match.Optional(String),\n            type: String,\n            label: String,\n            close: Match.Optional(Boolean),\n            result: Match.Optional(String),\n            data: Match.Optional(Match.Any),\n            cls: Match.Optional(String)\n        } ]),\n        cssClass: Match.Optional(String)\n    });\n\n    var dialog = MLDialog.createOnElement();\n\n    options = _prepareOptions(options);\n    dialog._dialog = {\n        options: options,\n        visible: false\n    };\n\n    dialog.template\n        .render(options)\n        .binder();\n\n    var dialogScope = dialog.container.scope;\n\n    if (options.close.backdrop)\n        dialog.events.on('click',\n            { subscriber: _onBackdropClick, context: dialog });\n\n    if (options.title && options.close.button)\n        dialogScope.closeBtn.events.on('click',\n            { subscriber: _onCloseBtnClick, context: dialog });\n\n    options.buttons.forEach(function(btn) {\n        var buttonSubscriber = {\n            subscriber: _.partial(_dialogButtonClick, btn),\n            context: dialog\n        };\n        dialogScope[btn.name].events.on('click', buttonSubscriber);\n    });\n\n    if (initialize) initialize(dialog);\n    return dialog;\n}\n\n\nfunction _dialogButtonClick(button) {\n    if (button.close !== false)\n        _toggleDialog.call(this, false);\n\n    var data = _.result(button.data, this, button);\n    _dispatchResult.call(this, button.result, data);\n}\n\n\nfunction _dispatchResult(result, data) {\n    var subscriber = this._dialog.subscriber;\n    if (typeof subscriber == 'function')\n        subscriber.call(this, result, data);\n    else\n        subscriber.subscriber.call(subscriber.context, result, data);\n}\n\n\nfunction _onBackdropClick(eventType, event) {\n    if (event.target == this.el)\n        this.closeDialog('dismissed');\n}\n\n\nfunction _onCloseBtnClick() {\n    this.closeDialog('closed');\n}\n\n\nfunction _onKeyDown(event) {\n    if (openedDialog\n            && openedDialog._dialog.options.close.keyboard\n            && event.keyCode == 27) // esc key\n        openedDialog.closeDialog('dismissed');\n}\n\n\nfunction _prepareOptions(options) {\n    options = _.clone(options);\n    options.buttons = _.clone(options.buttons || DEFAULT_BUTTONS);\n    options.buttons.forEach(function(btn) {\n        btn.name = btn.name || componentName();\n    });\n\n    options.close = typeof options.close == 'undefined' || options.close === true\n                        ? _.object(CLOSE_OPTIONS, true)\n                        : typeof options.close == 'object'\n                            ? _.mapToObject(CLOSE_OPTIONS,\n                                function(opt) { return options.close[opt] !== false; })\n                            : _.object(CLOSE_OPTIONS, false);\n\n    return options;\n}\n\n\n/**\n * Create and show dialog popup\n *\n * @param {Object} options object with title, text and buttons. See [createDialog](#MLDialog$$createDialog) for more information.\n * @param {Function|Object} subscriber optional subscriber function or object that is passed result and optional data. Unless context is defined, dialog will be the context.\n */\nfunction MLDialog$$openDialog(options, subscriber, initialize) {\n    var dialog = MLDialog.createDialog(options, initialize);\n    dialog.openDialog(subscriber);\n    return dialog;\n}\n\n\n\nfunction _toggleDialog(doShow) {\n    doShow = typeof doShow == 'undefined'\n                ? ! this._dialog.visible\n                : !! doShow;\n\n    var addRemove = doShow ? 'add' : 'remove'\n        , appendRemove = doShow ? 'appendChild' : 'removeChild';\n\n    this._dialog.visible = doShow;\n\n    if (doShow && ! dialogsInitialized)\n        _initializeDialogs();\n\n    document.body[appendRemove](this.el);\n    if (backdropEl)\n        document.body[appendRemove](backdropEl);\n    this.dom.toggle(doShow);\n    this.el.setAttribute('aria-hidden', !doShow);\n    document.body.classList[addRemove]('modal-open');\n    this.el.classList[addRemove]('in');\n\n    openedDialog = doShow ? this : undefined;\n    this.el[doShow ? 'focus' : 'blur']();\n}\n\n\nvar dialogsInitialized, backdropEl;\n\nfunction _initializeDialogs() {\n    backdropEl = document.createElement('div');\n    backdropEl.className = 'modal-backdrop fade in';\n    document.addEventListener('keydown', _onKeyDown);\n    dialogsInitialized = true;\n}\n\n\nvar openedDialog;\n\n/**\n * Opens dialog instance.\n * Subscriber object should have the same format as the subscriber for the Messenger (although Messenger is not used) - either function or object with subscriber and context properties.\n *\n * @param {Function|Object} subscriber subscriber object\n */\nfunction MLDialog$openDialog(subscriber) {\n    check(subscriber, Match.OneOf(Function, { subscriber: Function, context: Match.Any }));\n\n    if (openedDialog)\n        return logger.warn('MLDialog openDialog: can\\'t open dialog, another dialog is already open');\n\n    this._dialog.subscriber = subscriber;\n    _toggleDialog.call(this, true);\n}\n\n\n/**\n * Closes dialog instance, optionally passing result and data to dialog subscriber.\n * If no result is passed, 'closed' will be passed to subscriber.\n *\n * @param {String} result dialog result, passed as the first parameter to subcsriber\n * @param {Any} data optional dialog data, passed as the second parameter to subscriber\n */\nfunction MLDialog$closeDialog(result, data) {\n    if (! openedDialog)\n        return logger.warn('MLDialog closeDialog: can\\'t close dialog, no dialog open');\n\n    result = result || 'closed';\n\n    _toggleDialog.call(this, false);\n    _dispatchResult.call(this, result, data);\n}\n\n\n/**\n * Returns currently opened dialog\n *\n * @return {MLDialog}\n */\nfunction MLDialog$$getOpenedDialog() {\n    return openedDialog;\n}\n\n\nfunction MLDialog$destroy() {\n    document.removeEventListener('keydown', _onKeyDown);\n    Component.prototype.destroy.apply(this, arguments);\n}\n",
    "'use strict';\n\nvar Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , logger = milo.util.logger\n    , DOMListeners = milo.util.domListeners;\n\n\nvar TOGGLE_CSS_CLASS = 'dropdown-toggle'\n    , MENU_CSS_CLASS = 'dropdown-menu';\n\n\nvar MLDropdown = Component.createComponentClass('MLDropdown', {\n    events: undefined,\n    dom: {\n        cls: ['ml-bs-dropdown', 'dropdown']\n    }\n});\n\ncomponentsRegistry.add(MLDropdown);\n\nmodule.exports = MLDropdown;\n\n\n_.extendProto(MLDropdown, {\n    start: MLDropdown$start,\n    destroy: MLDropdown$destroy,\n    toggleMenu: MLDropdown$toggleMenu,\n    showMenu: MLDropdown$showMenu,\n    hideMenu: MLDropdown$hideMenu\n});\n\n\nfunction MLDropdown$start() {\n    var toggleEl = this.el.querySelector('.' + TOGGLE_CSS_CLASS)\n        , menuEl = this.el.querySelector('.' + MENU_CSS_CLASS);\n\n    if (! (toggleEl && menuEl))\n        return logger.error('MLDropdown:', TOGGLE_CSS_CLASS, 'or', MENU_CSS_CLASS, 'isn\\'t found');\n\n    var doc = window.document\n        , clickHandler = this.toggleMenu.bind(this, undefined);\n\n    var listeners = new DOMListeners;\n    this._dropdown = {\n        menu: menuEl,\n        visible: false,\n        listeners: listeners\n    };\n    this.hideMenu();\n    var self = this;\n\n    listeners.add(toggleEl, 'click', clickHandler);\n    //maybe only add this events if is open?\n    listeners.add(doc, 'mouseout', onDocOut);\n    listeners.add(doc, 'click', onClick);\n\n\n    function onDocOut(event) {\n        var target = event.target\n            , relatedTarget = event.relatedTarget\n            , listeners = self._dropdown.listeners;\n\n        if (isIframe(target))\n            listeners.remove(target.contentWindow.document, 'click', onClick);\n\n        if (isIframe(relatedTarget))\n            listeners.add(relatedTarget.contentWindow.document, 'click', onClick);\n    }\n\n    function onClick(event) {\n        if (!self.el.contains(event.target))\n            self.hideMenu();\n    }\n}\n\n\nfunction isIframe(el) {\n    return el && el.tagName == 'IFRAME';\n}\n\n\nfunction MLDropdown$destroy() {\n    this._dropdown.listeners.removeAll();\n    delete this._dropdown;\n    Component.prototype.destroy.apply(this, arguments);\n}\n\n\nfunction MLDropdown$showMenu() {\n    this.toggleMenu(true);\n}\n\n\nfunction MLDropdown$hideMenu() {\n    this.toggleMenu(false);\n}\n\n\nfunction MLDropdown$toggleMenu(doShow) {\n    doShow = typeof doShow == 'undefined'\n                ? ! this._dropdown.visible\n                : !! doShow;\n\n    this._dropdown.visible = doShow;\n\n    var menu = this._dropdown.menu;\n    menu.style.display = doShow\n                            ? 'block'\n                            : 'none';\n}\n",
    "'use strict';\n\nvar formGenerator = require('./generator')\n    , Component = milo.Component\n    , componentsRegistry = milo.registry.components\n    , check = milo.util.check\n    , logger = milo.util.logger\n    , formRegistry = require('./registry')\n    , async = require('async');\n\n\nvar FORM_VALIDATION_FAILED_CSS_CLASS = 'has-error';\n\n/**\n * A component class for generating forms from schema\n * To create form class method [createForm](#MLForm$$createForm) should be used.\n * Form schema has the following format:\n * ```\n * var schema = {\n *     css: {\n *                             // Optional CSS facet configuration\n *         classes: { ... }\n *     },\n *     items: [\n *         {\n *             type: '<type of ui control>',\n *                             // can be group, select, input, button, radio,\n *                             // hyperlink, checkbox, list, time, date\n *             compName: '<component name>',\n *                             // optional name of component, should be unique within the form\n *                             // (or form group), only needs tobe used when component needs to be\n *                             // manipilated in some event handler and it cannot be accessed via modelPath\n *                             // using `modelPathComponent` method\n *                             // (which is a preferred way to access conponents in form)\n *             label: '<ui control label>',\n *                             // optional label, will not be added if not defined\n *                             // or empty string\n *             altText: '<alt text or title>',\n *                             // optional alt text string on buttons and hyperlinks\n *             modelPath: '<model mapping>',\n *                             // path in model where the value will be stored.\n *                             // Most types of items require this property,\n *                             // some items may have this property (button, e.g.),\n *                             // \"group\" must NOT have this property.\n *                             // Warning will be logged if these rules are not followed.\n *                             // Items without this property will not be in model\n *                             // (apart from \"group which subitems will be in model\n *                             // if they have this property)\n *                             // This property allows to have fixed form model structure\n *                             // while changing view structure of the form\n *                             // See Model.\n *             modelPattern: 'mapping extension pattern',\n *                            // (string)\n *             notInModel: true,\n *                             //allows to NOT include modelPath where otherwise it would be required\n *             messages: {                      // to subscribe to messages on item's component facets\n *                 events: {                    // facet to subscribe to\n *                     '<message1>': onMessage1 // message and subscriber function\n *                     '<msg2> <msg3>': {       // subscribe to 2 messages\n *                         subscriber: onMessage2,\n *                         context: context     // context can be an object or a string:\n *                                              //    \"facet\": facet instance will be used as context\n *                                              //    \"owner\": item component instance will be used as context\n *                                              //    \"form\": the form component instance will be used as context\n *                                              //    \"host\": host object passed to createForm method will be used as context\n *                     }\n *                 }\n *             },\n *             translate: {          // optional data translation functions\n *                 context: Object   // optional context that will be passed to translate functions, 'host' means the hostObject passed to Form.createForm\n *                 toModel: func1,   // translates item data from view to model\n *                 fromModel: func2  // translates item data from model to view\n *             },\n *             validate: {           // optional data validation functions\n *                 context: Object   // optional context that will be passed to validate functions, 'host' means the hostObject passed to Form.createForm\n *                 toModel:   func1 | [func1, func2, ...],// validates item data when it is changed in form\n *                 fromModel: func2 | [func3, func4, ...] // opposite, but not really used and does not make form invalid if it fails.\n *                                                        // Can be used to prevent data being shown in the form.\n *             },                    // data validation functions should accept two parameters: data and callback (they are asynchronous).\n *                                   // when validation is finished, callback should be called with (error, response) parameters.\n *                                   // response should have properties valid (Boolean) and optional reason (String - reason of validation failure).\n *                                   // Note!: at the moment, if callback is called with error parameter which is not falsy, validation will be passed.\n *             <item specific>: {<item configuration>}\n *                             // \"select\" supports \"selectOptions\" - array of objects\n *                             // with properties \"value\" and \"label\"\n *                             // \"radio\" supports \"radioOptions\" with the same format\n *             items: [\n *                 { ... } //, ... - items inside \"group\" or \"wrapper\" item\n *             ]\n *         } // , ... more items\n *     ]\n * }\n */\nvar MLForm = Component.createComponentClass('MLForm', {\n    dom: {\n        cls: 'ml-form'\n    },\n    css: undefined, // Facet config can be set via form schema\n    model: undefined,\n    container: undefined,\n    data: undefined,\n    events: undefined\n});\n\ncomponentsRegistry.add(MLForm);\n\nmodule.exports = MLForm;\n\n\n_.extend(MLForm, {\n    createForm: MLForm$$createForm,\n    registerSchemaKey: MLForm$$registerSchemaKey,\n    registerValidation: MLForm$$registerValidation,\n    validatorResponse: MLForm$$validatorResponse,\n    generator: formGenerator,\n    registry: formRegistry\n});\n\n_.extendProto(MLForm, {\n    getHostObject: MLForm$getHostObject,\n    isValid: MLForm$isValid,\n    validateModel: MLForm$validateModel,\n    getInvalidControls: MLForm$getInvalidControls,\n    getInvalidReasons: MLForm$getInvalidReasons,\n    getInvalidReasonsText: MLForm$getInvalidReasonsText,\n    modelPathComponent: MLForm$modelPathComponent,\n    modelPathSchema: MLForm$modelPathSchema,\n    viewPathComponent: MLForm$viewPathComponent,\n    viewPathSchema: MLForm$viewPathSchema,\n    getModelPath: MLForm$getModelPath,\n    getViewPath: MLForm$getViewPath,\n    destroy: MLForm$destroy,\n});\n\n\nvar SCHEMA_KEYWORDS = _.object([\n    'type', 'compName', 'label', 'altText',\n    'modelPath', 'modelPattern', 'notInModel',\n    'messages', 'translate', 'validate', 'items',\n    'selectOptions', 'radioOptions', 'comboOptions',\n    'comboOptionsURL', 'addItemPrompt', 'placeHolder',\n    'value', 'dataValidation', 'asyncHandler', 'autoresize',\n    'maxLength'\n], true);\n\n/**\n * MLForm class method\n * Creates form from schema.\n * Form data can be obtained from its Model (`form.model`), reactive connection to form's model can also be used.\n *\n * @param {Object} schema form schema, as described above\n * @param {Object} hostObject form host object, used to define as message subscriber context in schema - by convention the context should be defined as \"host\"\n * @param {Object} formData data to initialize the form with\n * @param {String} template optional form template, will be used instead of automatically generated from schema. Not recommended to use, as it will have to be maintained to be consistent with schema for bindings.\n * @return {MLForm}\n */\nfunction MLForm$$createForm(schema, hostObject, formData, template) {\n    var FormClass = this;\n    var form = _createFormComponent(FormClass);\n    _.defineProperty(form, '_hostObject', hostObject);\n    var formViewPaths, formModelPaths, modelPathTranslations, dataTranslations, dataValidations;\n    _processFormSchema();\n    _createFormConnectors();\n    _manageFormValidation();\n\n    // set original form data\n    if (formData)\n        form.model.m.set(formData);\n\n    if (schema.css)\n        form.css.config = schema.css;\n\n    return form;\n\n\n    function _createFormComponent(FormClass) {\n        template = template || formGenerator(schema);\n        return FormClass.createOnElement(undefined, template);\n    }\n\n    function _processFormSchema() {\n        // model paths translation rules\n        formViewPaths = {};\n        formModelPaths = {};\n        modelPathTranslations = {};\n        dataTranslations = { fromModel: {}, toModel: {} };\n        dataValidations = { fromModel: {}, toModel: {} };\n\n        // process form schema\n        try {\n            processSchema.call(form, form, schema, '', formViewPaths, formModelPaths, modelPathTranslations, dataTranslations, dataValidations);\n        } catch (e) {\n            logger.debug('formViewPaths before error: ', formViewPaths);\n            logger.debug('formModelPaths before error: ', formModelPaths);\n            logger.debug('modelPathTranslations before error: ', modelPathTranslations);\n            logger.debug('dataTranslations before error: ', dataTranslations);\n            logger.debug('dataValidations before error: ', dataValidations);\n            throw (e);\n        }\n\n        form._formViewPaths = formViewPaths;\n        form._formModelPaths = formModelPaths;\n        form._modelPathTranslations = modelPathTranslations;\n        form._dataTranslations = dataTranslations;\n        form._dataValidations = dataValidations;\n    }\n\n    function _createFormConnectors() {\n        var connectors = form._connectors = [];\n\n        // connect form view to form model using translation rules from modelPath properties of form items\n        connectors.push(milo.minder(form.data, '<->', form.model, { // connection depth is defined on field by field basis by pathTranslation\n            pathTranslation: modelPathTranslations,\n            dataTranslation: {\n                '<-': dataTranslations.fromModel,\n                '->': dataTranslations.toModel\n            },\n            dataValidation: {\n                '<-': dataValidations.fromModel,\n                '->': dataValidations.toModel\n            }\n        }));\n\n        if (schema.css) {\n            connectors.push(milo.minder(form.model, '->>>', form.css));\n        }\n    }\n\n    function _manageFormValidation() {\n        form._invalidFormControls = {};\n\n        form.model.on('validated', createOnValidated(true));\n        form.data.on('validated', createOnValidated(false));\n\n        function createOnValidated(isFromModel) {\n            var pathCompMethod = isFromModel ? 'modelPathComponent': 'viewPathComponent'\n                , pathSchemaMethod = isFromModel ? 'modelPathSchema': 'viewPathSchema';\n\n            return function(msg, response) {\n                var component = form[pathCompMethod](response.path)\n                    , schema = form[pathSchemaMethod](response.path)\n                    , label = schema.label\n                    , modelPath = schema.modelPath;\n\n                if (component) {\n                    var parentEl = component.el.parentNode;\n                    parentEl.classList.toggle(FORM_VALIDATION_FAILED_CSS_CLASS, ! response.valid);\n\n                    var reason;\n                    if (response.valid)\n                        delete form._invalidFormControls[modelPath];\n                    else {\n                        reason = {\n                            label: label || '',\n                            reason: response.reason,\n                            reasonCode: response.reasonCode\n                        };\n                        form._invalidFormControls[modelPath] = {\n                            component: component,\n                            reason: reason\n                        };\n                    }\n\n                    var data = _.clone(response);\n\n                    if (!isFromModel) data.path = form.getModelPath(data.path);\n\n                    if (reason) {\n                        data.reason = reason; // a bit hacky, replacing string with object created above\n                        delete data.reasonCode;\n                    }\n                    form.postMessage('validation', data);\n                } else\n                    logger.error('Form: component for path ' + response.path + ' not found');\n            };\n        }\n    }\n}\n\n\n/**\n * Custom schema keywords\n */\nvar schemaKeywordsRegistry = {};\nfunction MLForm$$registerSchemaKey(keyword, processKeywordFunc, replaceKeyword) {\n    if (SCHEMA_KEYWORDS[keyword])\n        throw new Error('Keyword', keyword, 'is used by MLForm class or one of pre-registered form items and cannot be overridden');\n\n    if (!replaceKeyword && schemaKeywordsRegistry[keyword])\n        throw new Error('Keyword', keyword, 'is already registered. Pass true as the third parameter to replace it');\n\n    schemaKeywordsRegistry[keyword] = processKeywordFunc;\n}\n\n\n/**\n * Predefined form validation functions\n */\nvar validationFunctions = {\n    'required': validateRequired\n};\nfunction MLForm$$registerValidation(name, func, replaceFunc) {\n    if (!replaceFunc && validationFunctions[name])\n        throw new Error('Validating function', name, 'is already registered. Pass true as the third parameter to replace it');\n\n    validationFunctions[name] = func;\n}\n\n\n/**\n * Returns the form host object.\n * @return {Component}\n */\nfunction MLForm$getHostObject() {\n    return this._hostObject;\n}\n\n\n/**\n * Returns current validation status of the form\n * Will not validate fields that were never changed in view\n *\n * @return {Boolean}\n */\nfunction MLForm$isValid() {\n    return Object.keys(this._invalidFormControls).length == 0;\n}\n\n\n/**\n * Runs 'toModel' validators defined in schema on the current model of the form\n * can be used to mark as invaid all required fields or to explicitely validate\n * form when it is saved. Returns validation state of the form via callback\n *\n * @param {Function} callback\n */\nfunction MLForm$validateModel(callback) {\n    var validations = []\n        , self = this;\n\n    _.eachKey(this._dataValidations.fromModel, function(validators, modelPath) {\n        var data = this.model.m(modelPath).get();\n        validators = Array.isArray(validators) ? validators : [validators];\n\n        if (validators && validators.length) {\n            validations.push({\n                modelPath: modelPath,\n                data: data,\n                validators: validators\n            });\n        }\n    }, this);\n\n\n    var allValid = true;\n    async.each(validations,\n        function(validation, nextValidation) {\n            var lastResponse;\n            async.every(validation.validators,\n                // call validator\n                function(validator, next) {\n                    validator(validation.data, function(err, response) {\n                        lastResponse = response || {};\n                        next(lastResponse.valid || err);\n                    });\n                },\n            // post validation result of item to form\n            function(valid) {\n                lastResponse.path = validation.modelPath;\n                lastResponse.valid = valid;\n                self.model.postMessage('validated', lastResponse);\n                if (!valid) allValid = false;\n                nextValidation(null);\n            });\n        },\n    // post form validation result\n    function(err) {\n        self.postMessage('validationcompleted', { valid: allValid });\n        callback && callback(allValid);\n    });\n}\n\n\n/**\n * Returns map of invalid controls and reasons (view paths are keys)\n *\n * @return {Object}\n */\nfunction MLForm$getInvalidControls() {\n    return this._invalidFormControls;\n}\n\n\n/**\n * Returns an array of objects with all reasons for the form being invalid\n *\n * @return {Array[Object]}\n */\nfunction MLForm$getInvalidReasons() {\n    var invalidControls = this.getInvalidControls();\n    var reasons = _.reduceKeys(invalidControls,\n        function(memo, invalidControl, compName) {\n            memo.push(invalidControl.reason);\n            return memo;\n        }, [], this);\n    return reasons;\n}\n\n\n/**\n * Returns a multiline string with all reasons for the form being invalid\n *\n * @return {String}\n */\nfunction MLForm$getInvalidReasonsText() {\n    var reasons = this.getInvalidReasons();\n    return reasons.reduce(function(memo, reason) {\n        return memo + (reason.label || '') + ' - ' + reason.reason + '\\n';\n    }, '');\n}\n\n\n/**\n * Returns component for a given modelPath\n *\n * @param {String} modelPath\n * @return {Component}\n */\nfunction MLForm$modelPathComponent(modelPath) {\n    var modelPathObj = this._formModelPaths[modelPath];\n    return modelPathObj && modelPathObj.component;\n}\n\n\n/**\n * Returns form schema for a given modelPath\n *\n * @param {String} modelPath\n * @return {Object}\n */\nfunction MLForm$modelPathSchema(modelPath) {\n    var modelPathObj = this._formModelPaths[modelPath];\n    return modelPathObj && modelPathObj.schema;\n}\n\n\n/**\n * Returns component for a given view path (path as defined in Data facet)\n *\n * @param {String} viewPath\n * @return {Component}\n */\nfunction MLForm$viewPathComponent(viewPath) {\n    var viewPathObj = this._formViewPaths[viewPath];\n    return viewPathObj && viewPathObj.component;\n}\n\n\n/**\n * Returns form schema for a given view path item (path as defined in Data facet)\n *\n * @param {String} viewPath\n * @return {Object}\n */\nfunction MLForm$viewPathSchema(viewPath) {\n    var viewPathObj = this._formViewPaths[viewPath];\n    return viewPathObj && viewPathObj.schema;\n}\n\n\n/**\n * Converts view path of the component in the form to the model path of the connected data\n *\n * @param {string} viewPath view path of the component\n * @return {string} model path of connected data\n */\nfunction MLForm$getModelPath(viewPath) {\n    return this._modelPathTranslations[viewPath];\n}\n\n\n/**\n * Converts model path of the connected data to view path of the component in the form\n * \n * @param {string} modelPath model path of connected data\n * @return {string} view path of the component\n */\nfunction MLForm$getViewPath(modelPath) {\n    return _.findKey(this._modelPathTranslations, function(mPath, vPath) {\n        return mPath == modelPath;\n    });\n}\n\n\nfunction MLForm$destroy() {\n    Component.prototype.destroy.apply(this, arguments);\n\n    this._connectors && this._connectors.forEach(milo.minder.destroyConnector);\n    this._connectors = null;\n}\n\n\n/**\n * See item_types.js for item classes and templates\n * Map of items types to items components classes\n * UI components are defined in `milo`\n */\n\n\n// var _itemsSchemaRules = _.mapKeys(itemTypes, function(className, itemType) {\n//     return {\n//         // CompClass: componentsRegistry.get(className),\n//         func: itemsFunctions[itemType] || doNothing,\n//         modelPathRule: modelPathRules[itemType] || 'required'\n//     };\n// });\n\nfunction doNothing() {}\n\n\n/**\n * Processes form schema to subscribe for messages as defined in schema. Performs special processing for some types of items.\n * Returns translation rules for Connector object.\n * This function is called recursively for groups (and subgroups)\n *\n * @private\n * @param {Component} comp form or group component\n * @param {Object} schema form or group schema\n * @param {String} viewPath current view path, used to generate Connector translation rules\n * @param {Object} formViewPaths view paths accumulated so far (have component and schema properties)\n * @param {Object} formModelPaths view paths accumulated so far (have component and schema properties)\n * @param {Object} modelPathTranslations model path translation rules accumulated so far\n * @param {Object} dataTranslations data translation functions so far\n * @param {Object} dataValidations data validation functions so far\n * @return {Object}\n */\nfunction processSchema(comp, schema, viewPath, formViewPaths, formModelPaths, modelPathTranslations, dataTranslations, dataValidations) {\n    viewPath = viewPath || '';\n    formViewPaths = formViewPaths || {};\n    formModelPaths = formModelPaths || {};\n    modelPathTranslations = modelPathTranslations || {};\n    dataTranslations = dataTranslations || {};\n    dataTranslations.fromModel = dataTranslations.fromModel || {};\n    dataTranslations.toModel = dataTranslations.toModel || {};\n\n    dataValidations = dataValidations || {};\n    dataValidations.fromModel = dataValidations.fromModel || {};\n    dataValidations.toModel = dataValidations.toModel || {};\n\n    if (schema.items)\n        _processSchemaItems.call(this, comp, schema.items, viewPath, formViewPaths, formModelPaths, modelPathTranslations, dataTranslations, dataValidations);\n\n    if (schema.messages)\n        _processSchemaMessages.call(this, comp, schema.messages);\n\n    var itemRule = schema.type && formRegistry.get(schema.type);\n    var hostObject = this.getHostObject();\n\n    if (viewPath) {\n        formViewPaths[viewPath] = {\n            schema: schema,\n            component: comp\n        };\n\n        if (itemRule) {\n            //check(comp.constructor, itemTypes[schema.type].CompClass);\n            itemRule.itemFunction && itemRule.itemFunction.call(hostObject, comp, schema);\n            _processItemTranslations.call(this, viewPath, schema);\n        } else\n            throw new Error('unknown item type ' + schema.type);\n    }\n\n    for (var keyword in schemaKeywordsRegistry) {\n        if (schema.hasOwnProperty(keyword)) {\n            var processKeywordFunc = schemaKeywordsRegistry[keyword];\n            processKeywordFunc(hostObject, comp, schema);\n        }\n    }\n\n    return modelPathTranslations;\n\n\n    function _processItemTranslations(viewPath, schema) {\n        var modelPath = schema.modelPath\n            , modelPattern = schema.modelPattern || ''\n            , notInModel = schema.notInModel\n            , translate = schema.translate\n            , validate = schema.validate;\n\n        if (viewPath) {\n            _addDataTranslation.call(this, translate, 'toModel', viewPath);\n\n            switch (itemRule.modelPathRule) {\n                case 'prohibited':\n                    if (modelPath)\n                        throw new Error('modelPath is prohibited for item type ' + schema.type);\n                    break;\n                case 'required':\n                    if (! (modelPath || notInModel))\n                        throw new Error('modelPath is required for item type ' + schema.type + ' . Add \"notInModel: true\" to override');\n                    // falling through to 'optional'\n                case 'optional':\n                    if (modelPath) {\n                        formModelPaths[modelPath] = {\n                            schema: schema,\n                            component: comp\n                        };\n\n                        if (! notInModel) {\n                            _addModelPathTranslation(viewPath, modelPath, modelPattern);\n                            _addDataTranslation.call(this, translate, 'fromModel', modelPath);\n                            _addDataValidation.call(this, validate, 'toModel', viewPath);\n                            _addDataValidation.call(this, validate, 'fromModel', modelPath);\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error('unknown modelPath rule for item type ' + schema.type);\n            }\n        }\n    }\n\n    function _addModelPathTranslation(viewPath, modelPath, pathPattern) {\n        if (viewPath in modelPathTranslations)\n            throw new Error('duplicate view path ' + viewPath);\n        else if (_.keyOf(modelPathTranslations, modelPath))\n            throw new Error('duplicate model path ' + modelPath + ' for view path ' + viewPath);\n        else\n            modelPathTranslations[viewPath + pathPattern] = modelPath + pathPattern;\n    }\n\n    function _addDataTranslation(translate, direction, path) {\n        var translateFunc = translate && translate[direction];\n        if (!translateFunc) return;\n        if (typeof translateFunc == 'function') {\n            if (translate.context) {\n                var context = getFunctionContext.call(this, translate.context);\n\n                translateFunc = translateFunc.bind(context);\n            }\n            dataTranslations[direction][path] = translateFunc;\n        } else {\n            throw new Error(direction + ' translator for ' + path + ' should be function');\n        }\n    }\n\n    function _addDataValidation(validate, direction, path) {\n        var validators = validate && validate[direction];\n        if (! validators) return;\n\n        var form = this;\n        var formValidators = dataValidations[direction][path] = [];\n\n        if (Array.isArray(validators))\n            validators.forEach(_addValidatorFunc);\n        else\n            _addValidatorFunc(validators);\n\n        function _addValidatorFunc(validator) {\n            if (typeof validator == 'string')\n                var valFunc = getValidatorFunction(validator);\n            else if (validator instanceof RegExp)\n                valFunc = makeRegexValidator(validator);\n            else if (typeof validator == 'function')\n                valFunc = validator;\n            else\n                throw new Error(direction + ' validator for ' + path + ' should be function or string');\n\n            if (validate.context) {\n                var context = getFunctionContext.call(form, validate.context);\n\n                valFunc = valFunc.bind(context);\n            }\n\n            formValidators.push(valFunc);\n        }\n    }\n}\n\n\nfunction getValidatorFunction(validatorName) {\n    var valFunc = validationFunctions[validatorName];\n    if (! valFunc)\n        throw new Error('Form: unknown validator function name ' + validatorName);\n    return valFunc;\n}\n\n\nfunction makeRegexValidator(validatorRegExp) {\n    return function (data, callback) {\n        var valid = validatorRegExp.test(data)\n            , response = MLForm$$validatorResponse(valid, 'should match pattern');\n        callback(null, response);\n    };\n}\n\n\n/**\n * Processes items of the form (or group).\n * Component that has items should have Container facet.\n * Returns translation rules for Connector.\n *\n * @private\n * @param {Component} comp form or group component\n * @param {Array} items list of items in schema\n * @param {String} viewPath current view path, used to generate Connector translation rules\n * @param {Object} formViewPaths view paths accumulated so far (have component and schema properties)\n * @param {Object} formModelPaths view paths accumulated so far (have component and schema properties)\n * @param {Object} modelPathTranslations model path translation rules accumulated so far\n * @param {Object} dataTranslations data translation functions so far\n * @param {Object} dataValidations data validation functions so far\n * @return {Object}\n */\nfunction _processSchemaItems(comp, items, viewPath, formViewPaths, formModelPaths, modelPathTranslations, dataTranslations, dataValidations) {\n    if (! comp.container)\n        return logger.warn('Form Warning: schema has items but component has no container facet');\n\n    items.forEach(function(item) {\n        if (!item.compName) return; // No component, only markup\n\n        var itemComp = comp.container.scope[item.compName]\n            , compViewPath = viewPath + '.' + item.compName;\n        if (! itemComp)\n            throw new Error('component \"' + item.compName + '\" is not in scope (or subscope) of form');\n        processSchema.call(this, itemComp, item, compViewPath, formViewPaths, formModelPaths, modelPathTranslations, dataTranslations, dataValidations);\n    }, this);\n}\n\n\n/**\n * Subscribes to messages on facets of items' component as defined in schema\n */\nfunction _processSchemaMessages(comp, messages) {\n    var form = this;\n    _.eachKey(messages, function(facetMessages, facetName) {\n        var facet = comp[facetName];\n        if (! facet)\n            throw new Error('schema has subscriptions for facet \"' + facetName + '\" of form component \"' + comp.name + '\", but component has no facet');\n        facetMessages = _.clone(facetMessages);\n        _.eachKey(facetMessages, function(subscriber, messageType) {\n            var context = typeof subscriber == 'object' ? subscriber.context : null;\n\n            // Avoid changing event subscriptions whose context is 'facet' or 'owner'.\n            if (context && context != 'facet' && context != 'owner') {\n                context = getFunctionContext.call(form, context);\n\n                facetMessages[messageType] = {\n                    subscriber: subscriber.subscriber,\n                    context: context\n                };\n            }\n        });\n        facet.onConfigMessages(facetMessages);\n    });\n}\n\n\n/**\n * Returns the object to bind a function to as defined by a section of the form schema.\n *\n * Currently supported inputs are:\n *  - {Object} - Any object\n *  - {String} 'form' - The form\n *  - {String} 'host' - The form's host object\n */\nfunction getFunctionContext(context) {\n    if (context == 'form')\n        context = this;\n    else if (context == 'host')\n        context = this.getHostObject();\n\n    if (context && typeof context != 'object')\n        throw new Error('Invalid context supplied - Expected {String} [host,form], or {Object}');\n\n    return context;\n}\n\n\n/**\n * Validation functions\n */\nfunction validateRequired(data, callback) {\n    var valid = typeof data != 'undefined'\n                && (typeof data != 'string' || data.trim() != '');\n    var response = MLForm$$validatorResponse(valid, 'please enter a value', 'REQUIRED');\n    callback(null, response);\n}\n\n\nfunction MLForm$$validatorResponse(valid, reason, reasonCode) {\n    return valid\n            ? { valid: true }\n            : { valid: false, reason: reason, reasonCode: reasonCode };\n}\n",
    "'use strict';\n\nvar doT = milo.util.doT\n    , fs = require('fs')\n    , componentsRegistry = milo.registry.components\n    , miloCount = milo.util.count\n    , componentName = milo.util.componentName\n    , formRegistry = require('./registry')\n    , itemTypes = require('./item_types');\n\nvar cachedItems = {};\n\n\nmodule.exports = formGenerator;\n\n\nvar partials = {\n    label: \"{{? it.item.label }}\\n    <label>{{= it.item.label}}</label>\\n{{?}}\\n\",\n    formGroup: \"<div\\n    {{? it.item.altText }}title=\\\"{{= it.item.altText}}\\\" {{?}}\\n    class=\\\"form-group{{? it.item.wrapCssClass}} {{= it.item.wrapCssClass }}{{?}}\\\"\\n>\\n\"\n};\n\nvar dotDef = {\n    partials: partials\n};\n\n\n/*\n * Generates form HTML based on the schema.\n * It does not create components for the form DOM, milo.binder should be called separately on the form's element.\n *\n * @param {Array} schema array of form elements descriptors\n * @return {String}\n */\nfunction formGenerator(schema) {\n    //getItemsClasses();\n\n    var renderedItems = schema.items.map(renderItem);\n    return renderedItems.join('');\n\n    function renderItem(item) {\n        var itemType = cachedItems[item.type];\n\n        if (!itemType) {\n            var newItemType = formRegistry.get(item.type);\n            itemType = cachedItems[item.type] = {\n                CompClass: newItemType.compClass && componentsRegistry.get(newItemType.compClass),\n                compClass: newItemType.compClass,\n                template: doT.compile(newItemType.template, dotDef)\n            }\n        }\n\n        item.compName = itemType.CompClass ? item.compName || componentName() : null;\n\n        var domFacetConfig = itemType.CompClass && itemType.CompClass.getFacetConfig('dom')\n            , tagName = domFacetConfig && domFacetConfig.tagName || 'div';\n\n        var template = itemType.template;\n        return template({\n            item: item,\n            compName: item.compName,\n            compClass: itemType.compClass,\n            tagName: tagName,\n            formGenerator: formGenerator,\n            miloCount: miloCount,\n            disabled: item.disabled,\n            multiple: item.multiple\n        });\n    }\n}\n",
    "'use strict';\n\n\nvar fs = require('fs')\n    , formRegistry = require('./registry');\n\n\nvar group_dot = \"<div ml-bind=\\\"MLGroup:{{= it.compName }}\\\"{{? it.item.wrapCssClass}} class=\\\"{{= it.item.wrapCssClass }}\\\"{{?}}>\\n    {{# def.partials.label }}\\n    {{= it.formGenerator(it.item) }}\\n</div>\\n\"\n    , wrapper_dot = \"<span ml-bind=\\\"MLWrapper:{{= it.compName }}\\\"{{? it.item.wrapCssClass}} class=\\\"{{= it.item.wrapCssClass }}\\\"{{?}}>\\n    {{= it.formGenerator(it.item) }}\\n</span>\\n\"\n    , select_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n    <span class=\\\"custom-select\\\">\\n        <select ml-bind=\\\"MLSelect:{{= it.compName }}\\\"\\n                {{? it.disabled }}disabled {{?}}\\n                {{? it.multiple }}multiple {{?}}\\n                class=\\\"form-control\\\">\\n        </select>\\n    </span>\\n</div>\\n\"\n    , input_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n    <input type=\\\"{{= it.item.inputType || 'text' }}\\\"\\n            {{? it.item.inputName }}name=\\\"{{= it.item.inputName }}\\\"{{?}}\\n            ml-bind=\\\"MLInput:{{= it.compName }}\\\"\\n            {{? it.item.placeholder }}placeholder=\\\"{{= it.item.placeholder}}\\\"{{?}}\\n            {{? it.disabled }}disabled {{?}}\\n            class=\\\"form-control\\\">\\n</div>\\n\"\n    , textarea_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n    <textarea ml-bind=\\\"MLTextarea:{{= it.compName }}\\\"\\n        {{? it.disabled }}disabled {{?}}\\n        class=\\\"form-control\\\"\\n        {{? it.item.placeholder }}placeholder=\\\"{{= it.item.placeholder}}\\\"{{?}}\\n        {{? it.item.autoresize }}rows=\\\"{{= it.item.autoresize.minLines }}\\\"{{?}}></textarea>\\n</div>\"\n    , button_dot = \"<div {{? it.item.altText }}title=\\\"{{= it.item.altText}}\\\" {{?}}class=\\\"btn-toolbar{{? it.item.wrapCssClass}} {{= it.item.wrapCssClass }}{{?}}\\\">\\n    <button ml-bind=\\\"MLButton:{{= it.compName }}\\\"\\n        {{? it.disabled }}disabled {{?}}\\n        class=\\\"btn btn-default {{? it.item.itemCssClass}} {{= it.item.itemCssClass }}{{?}}\\\">\\n        {{= it.item.label || '' }}\\n    </button>\\n</div>\\n\"\n    , hyperlink_dot = \"{{# def.partials.formGroup }}\\n    <a {{? it.item.href}}href=\\\"{{= it.item.href }}\\\"{{?}}\\n        {{? it.item.target}}target=\\\"{{= it.item.target }}\\\"{{?}}   \\n        ml-bind=\\\"MLHyperlink:{{= it.compName }}\\\" \\n        class=\\\"hyperlink hyperlink-default\\\">\\n        {{= it.item.label || '' }}\\n    </a>\\n</div>\"\n    , checkbox_dot = \"{{# def.partials.formGroup }}\\n  <input type=\\\"checkbox\\\"\\n    id=\\\"{{= it.compName }}\\\"\\n    ml-bind=\\\"MLInput:{{= it.compName }}\\\"\\n    {{? it.disabled }}disabled {{?}}\\n    class=\\\"{{= it.item.itemCssClass || ''}}\\\">\\n  <label for=\\\"{{= it.compName }}\\\">{{= it.item.label}}</label>\\n</div>\\n\"\n    , list_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n    <ul ml-bind=\\\"MLList:{{= it.compName }}\\\"\\n            {{? it.disabled }}disabled {{?}}>\\n        <li ml-bind=\\\"MLListItem:itemSample\\\" class=\\\"list-item\\\">\\n            <span ml-bind=\\\"[data]:label\\\"></span>\\n            {{? it.editBtn }}<button ml-bind=\\\"[events]:editBtn\\\">edit</button>{{?}}\\n            <button ml-bind=\\\"[events]:deleteBtn\\\" class=\\\"btn btn-default glyphicon glyphicon-remove\\\"> </button>\\n        </li>\\n    </ul>\\n</div>\\n\"\n    , time_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n    <input type=\\\"time\\\"\\n            ml-bind=\\\"MLTime:{{= it.compName }}\\\"\\n            class=\\\"form-control\\\">\\n</div>\"\n    , date_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n    <input type=\\\"date\\\"\\n            ml-bind=\\\"MLDate:{{= it.compName }}\\\"\\n            class=\\\"form-control\\\">\\n</div>\"\n    , combo_dot = \"<div ml-bind=\\\"MLCombo:{{= it.compName }}\\\" class=\\\"form-group{{? it.item.wrapCssClass}} {{= it.item.wrapCssClass }}{{?}}\\\">\\n    {{# def.partials.label }}\\n    {{ var listID = 'ml-combo-datalist-' + it.miloCount(); }}\\n    <input ml-bind=\\\"[data, events]:input\\\"\\n            name=\\\"{{= listID }}\\\"\\n            list=\\\"{{= listID }}\\\"\\n            {{? it.disabled }}disabled {{?}}\\n            class=\\\"form-control\\\">\\n    <datalist id=\\\"{{= listID }}\\\" ml-bind=\\\"[template]:datalist\\\"></datalist>\\n</div>\"\n    , image_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n    <img {{? it.item.src }}src=\\\"{{= it.item.src }}\\\"{{?}}\\n        ml-bind=\\\"MLImage:{{= it.compName }}\\\"\\n        {{? it.item.width }}width=\\\"{{= it.item.width }}\\\"{{?}}\\n        {{? it.item.height }}height=\\\"{{= it.item.height }}\\\"{{?}}>\\n</div>\\n\"\n    , droptarget_dot = \"{{# def.partials.formGroup }}\\n    {{# def.partials.label }}\\n        <img {{? it.item.src }}src=\\\"{{= it.item.src }}\\\"{{?}}\\n            ml-bind=\\\"MLDropTarget:{{= it.compName }}\\\"\\n            {{? it.item.width }}width=\\\"{{= it.item.width }}\\\"{{?}}\\n            {{? it.item.height }}height=\\\"{{= it.item.height }}\\\"{{?}}>\\n</div>\\n\"\n    , text_dot = \"{{var tagName = it.item.tagName || 'span';}}\\n<{{=tagName}} ml-bind=\\\"MLText:{{= it.compName }}\\\"{{? it.item.wrapCssClass}} class=\\\"{{= it.item.wrapCssClass }}\\\"{{?}}>\\n    {{? it.item.label }}\\n        {{= it.item.label}}\\n    {{?}}\\n</{{=tagName}}>\\n\"\n    , clear_dot = '<div class=\"cc-clear\"></div>';\n\n\nformRegistry.add('group',                 { compClass: 'MLGroup',                 template: group_dot,                 modelPathRule: 'prohibited'                                           });\nformRegistry.add('wrapper',               { compClass: 'MLWrapper',               template: wrapper_dot,               modelPathRule: 'prohibited'                                           });\nformRegistry.add('select',                { compClass: 'MLSelect',                template: select_dot,                                             itemFunction: processSelectSchema        });\nformRegistry.add('input',                 { compClass: 'MLInput',                 template: input_dot,                                              itemFunction: processInputSchema         });\nformRegistry.add('inputlist',             { compClass: 'MLInputList',                                                                               itemFunction: processInputListSchema     });\nformRegistry.add('textarea',              { compClass: 'MLTextarea',              template: textarea_dot,                                           itemFunction: processTextareaSchema      });\nformRegistry.add('button',                { compClass: 'MLButton',                template: button_dot,                modelPathRule: 'optional'                                             });\nformRegistry.add('radio',                 { compClass: 'MLRadioGroup',                                                                              itemFunction: processRadioSchema         });\nformRegistry.add('checkgroup',            { compClass: 'MLCheckGroup',                                                                              itemFunction: processCheckGroupSchema         });\nformRegistry.add('hyperlink',             { compClass: 'MLHyperlink',             template: hyperlink_dot,             modelPathRule: 'optional'                                             });\nformRegistry.add('checkbox',              { compClass: 'MLInput',                 template: checkbox_dot                                                                                     });\nformRegistry.add('list',                  { compClass: 'MLList',                  template: list_dot                                                                                         });\nformRegistry.add('time',                  { compClass: 'MLTime',                  template: time_dot,                                                                                        });\nformRegistry.add('date',                  { compClass: 'MLDate',                  template: date_dot                                                                                         });\nformRegistry.add('combo',                 { compClass: 'MLCombo',                 template: combo_dot,                                              itemFunction: processComboSchema         });\nformRegistry.add('supercombo',            { compClass: 'MLSuperCombo',                                                                              itemFunction: processSuperComboSchema    });\nformRegistry.add('combolist',             { compClass: 'MLComboList',                                                                               itemFunction: processComboListSchema     });\nformRegistry.add('image',                 { compClass: 'MLImage',                 template: image_dot                                                                                        });\nformRegistry.add('droptarget',            { compClass: 'MLDropTarget',            template: droptarget_dot,            modelPathRule: 'prohibited'                                           });\nformRegistry.add('text',                  { compClass: 'MLText',                  template: text_dot,                  modelPathRule: 'optional'                                             });\nformRegistry.add('clear',                 {                                       template: clear_dot                                                                                        });\n\n\nfunction processSelectSchema(comp, schema) {\n    var options = schema.selectOptions;\n    setComponentOptions(comp, options, setComboOptions);\n}\n\n\nfunction processRadioSchema(comp, schema) {\n    var options = schema.radioOptions;\n    setComponentOptions(comp, options, setComponentModel);\n}\n\n\nfunction processCheckGroupSchema(comp, schema) {\n    var options = schema.checkOptions;\n    comp.setSelectAll(!!schema.selectAll);\n    setComponentOptions(comp, options, setComponentModel);\n}\n\n\nfunction processComboSchema(comp, schema) {\n    var options = schema.comboOptions;\n    setComponentOptions(comp, options, setComponentModel);\n}\n\n\nfunction processSuperComboSchema(comp, schema) {\n    var options = schema.comboOptions\n        , optionsURL = schema.comboOptionsURL\n        , addItemPrompt = schema.addItemPrompt\n        , placeHolder = schema.placeHolder;\n\n    _.deferTicks(function() {\n        if (addItemPrompt) comp.setAddItemPrompt(addItemPrompt);\n        if (placeHolder) comp.setPlaceholder(placeHolder);\n        setComponentOptions(comp, options, setComboOptions);\n        if(optionsURL)\n            comp.initOptionsURL(optionsURL);\n    }, 2);\n}\n\n\nfunction processComboListSchema(comp, schema) {\n    var options = schema.comboOptions\n        , addItemPrompt = schema.addItemPrompt\n        , placeHolder = schema.placeHolder;\n\n    _.deferTicks(function() {\n        if (addItemPrompt) comp.setAddItemPrompt(addItemPrompt);\n        if (placeHolder) comp.setPlaceholder(placeHolder);\n        comp.setDataValidation(schema.dataValidation);\n        setComponentOptions(comp, options, setComboOptions);\n    }, 2);\n}\n\n\nfunction processInputListSchema(comp, schema) {\n    comp.setAsync(schema.asyncHandler);\n    comp.setPlaceHolder(schema.placeHolder);\n}\n\n\nfunction processTextareaSchema(comp, schema) {\n    if (schema.autoresize)\n        _.deferMethod(comp, 'startAutoresize', schema.autoresize);\n}\n\n\nfunction processInputSchema(comp, schema) {\n    if (_.isNumeric(schema.maxLength)) comp.setMaxLength(schema.maxLength);\n}\n\nfunction setComponentOptions(comp, options, setModelFunc) {\n    if (options) {\n        if (typeof options.then == 'function') {\n            setModelFunc(comp, [{ value: 0, label: 'loading...' }]);\n            options\n                .then(\n                    function(data) { setModelFunc(comp, data); },\n                    function() { setModelFunc(comp, [{ value: 0, label: 'loading error' }]); }\n                );\n        } else\n            setModelFunc(comp, options);\n    }\n}\n\n\nfunction setComponentModel(comp, data) {\n    comp.model.set(data);\n    // _.deferMethod(comp.model, 'set', data);\n    // doing it with defer makes channel not set when the article is opened\n}\n\n\nfunction setComboOptions(comp, data) {\n    comp.setOptions(data);\n}\n\n\nfunction processSchema(comp, schema) {\n    comp.processFormSchema(schema);\n}\n",
    "'use strict';\n\nvar logger = milo.util.logger\n    , check = milo.util.check\n    , Component = milo.Component\n    , Match = check.Match;\n\nvar formTypes = {};\nvar defaults = {};\n\nvar formRegistry = module.exports = {\n    get: registry_get,\n    add: registry_add,\n    setDefaults: registry_setDefaults\n};\n\n\nvar DEFAULT_TEMPLATE = '{{# def.partials.formGroup }}\\\n                            {{# def.partials.label }}\\\n                            <{{= it.tagName}} ml-bind=\"{{= it.compClass}}:{{= it.compName }}\">\\\n                            </{{= it.tagName}}>\\\n                        </div>';\n\nformRegistry.setDefaults({\n    template: DEFAULT_TEMPLATE,\n    modelPathRule: 'required',\n    itemFunction: null\n});\n\n\nfunction registry_get(name) {\n    var formItem = name && formTypes[name];\n\n    if (!formItem) \n        return logger.error('Form item ' + name + ' not registered');\n\n    return formItem;\n}\n\nfunction registry_add(name, newFormItem) {\n    check(name, String);\n    check(newFormItem, {\n        compClass: Match.Optional(String),\n        template: Match.Optional(String),\n        modelPathRule: Match.Optional(String),\n        itemFunction: Match.Optional(Function)\n    });\n\n    var formItem = _.clone(defaults);\n    _.extend(formItem, newFormItem);\n\n    if (name && formTypes[name]) \n        return logger.error('Form item ' + name + ' already registered');\n\n    formTypes[name] = formItem;\n    return true;\n}\n\nfunction registry_setDefaults(newDefaults) {\n    check(defaults, Object);\n    defaults = newDefaults;\n}\n\n",
    "'use strict';\n\nif (!(window.milo && window.milo.milo_version))\n    throw new Error('milo is not available');\n\n/**\n * `milo-ui`\n *\n * This bundle will register additional component classes for UI\n */\n\nrequire('./use_components');\n",
    "'use strict';\n\nrequire('./components/Group');\nrequire('./components/Wrapper');\nrequire('./components/Text');\nrequire('./components/Select');\nrequire('./components/Input');\nrequire('./components/InputList');\nrequire('./components/Textarea');\nrequire('./components/RadioGroup');\nrequire('./components/CheckGroup');\nrequire('./components/Button');\nrequire('./components/Hyperlink');\nrequire('./components/List');\nrequire('./components/ListItemSimple');\nrequire('./components/ListItem');\nrequire('./components/Time');\nrequire('./components/Date');\nrequire('./components/Combo');\nrequire('./components/SuperCombo');\nrequire('./components/ComboList');\nrequire('./components/Image');\nrequire('./components/DropTarget');\nrequire('./components/FoldTree');\n\nrequire('./components/bootstrap/Alert');\nrequire('./components/bootstrap/Dialog');\nrequire('./components/bootstrap/Dropdown');\n\nrequire('./forms/Form');\n",
    "var process=require(\"__browserify_process\"),global=typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n",
    "\n// not implemented\n// The reason for having an empty file and not throwing is to allow\n// untraditional implementation of this module.\n",
    "// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n"
  ]
}